<!DOCTYPE html>
<html lang="en-us">

  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    
      Singularity.be &middot; Flawed logic inspecting flawed logic
    
  </title>

  <!-- CSS -->
  <link rel="stylesheet" href="/public/css/poole.css">
  <link rel="stylesheet" href="/public/css/syntax.css">
  <link rel="stylesheet" href="/public/css/hyde.css">
  <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface">

  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/public/apple-touch-icon-144-precomposed.png">
                                 <link rel="shortcut icon" href="/public/favicon.ico">

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml">
</head>


  <body>

    <div class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <h1>
        <a href="/">
          Singularity.be
        </a>
      </h1>
      <p class="lead">Steven Van Acker's blog</p>
    </div>

    <nav class="sidebar-nav">
      <a class="sidebar-nav-item" href="/">Home</a>

      

      
      
        
          
        
      
        
          
            <a class="sidebar-nav-item" href="/about/">About</a>
          
        
      
        
          
        
      
        
      
        
          
        
      
        
          
            <a class="sidebar-nav-item" href="/projects/">Projects</a>
          
        
      
        
          
            <a class="sidebar-nav-item" href="/publications/">Publications</a>
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
    </nav>

    <!-- <p>&copy; 2016. All rights reserved.</p> -->
  </div>
</div>


    <div class="content container">
      <div class="posts">
  
  <div class="post">
    <h1 class="post-title">
      <a href="/2006/02/17/automated-installations-6/">
        automated installations (6)
      </a>
    </h1>

    <span class="post-date">17 Feb 2006</span>

    The bugreports and patches are on their way to bugs.debian.org.<br /><br />I've been looking at the whole hostname thing again. <br />The code in the base-config package is executed after the first reboot. That means the hostname is already set at that point (by the netcfg package :( )<br /><br />Some things to keep in mind when altering base-config udeb:<br /><br /><ul><br /><li>it has an md5sums file you need to regenerate</li><br /><li>the Packages file is somewhere else</li><br /><li>the Packages file contains a "Size:" field you need to modify</li><br /></ul><br /><br />I've attached the scripts to pack and unpack the base-config package.<br /><br />By inserting a "sleep 1800" into the script to set the hostname, I was able to view what files existed before the script ran. My idea is that I can maybe alter those files with the real hostname and then continue the installation.<br /><br />These files contain the hostname right before the base-config script:<br /><br /><pre><br />/etc/hostname<br />/etc/hosts<br />/etc/motd<br />/etc/exim4/update-exim4.conf.conf<br />/etc/mailname<br />/var/lib/exim4/config.autogenerated<br />/var/cache/debconf/config.dat<br />/var/cache/debconf/config.dat-old<br />/var/log/syslog<br />/var/log/auth.log<br />/var/log/debian-installer/cdebconf/questions.dat<br />/var/log/kern.log<br />/var/log/user.log<br />/var/log/debug<br />/var/log/messages<br /></pre><br /><br />Notice how /var/log/user.log exists but seems to be erased after the installation completes ?<br />These files are created after the base-config script:<br /><br /><pre><br />/etc/ssh/ssh_host_rsa_key.pub<br />/etc/ssh/ssh_host_dsa_key.pub<br />/var/log/exim4/mainlog<br />/var/log/daemon.log<br />/var/log/lpr.log<br />/var/spool/mail/mail<br />/var/mail/mail<br /></pre><br /><br />OK, So from all the files that already exist, I decide that these are important:<br /><pre><br />/etc/hostname<br />/etc/hosts<br />/etc/motd<br />/etc/mailname<br />/var/cache/debconf/config.dat<br />/var/cache/debconf/config.dat-old<br /></pre><br /><br />And these are not:<br /><pre><br />/etc/exim4/update-exim4.conf.conf<br />/var/lib/exim4/config.autogenerated<br />/var/log/syslog<br />/var/log/auth.log<br />/var/log/debian-installer/cdebconf/questions.dat<br />/var/log/kern.log<br />/var/log/user.log<br />/var/log/debug<br />/var/log/messages<br /></pre><br /><br />The reason why exim4 config is not important is because exim will be removed in favor of postfix anyway. The rest of the unimportant files are just logs.<br /><br />Let's review the files that need to be changed:<br /><dl><br /><dt>/etc/hostname</dt><br /><dd>This file contains the hostname and is generated by the netcfg package. This is one we need to change.</dd><br /><dt>/etc/hosts</dt><br /><dd>This file contains IP to hostname mappings and is also generated by the netcfg package. We will need our own custom version of this file anyway, so maybe it can be generated by a custom package later on.</dd><br /><dt>/etc/motd</dt><br /><dd>This file contains the message of the day and is generated at boot by /etc/init.d/bootmisc.sh from whatever uname returns. Could not care less about it :)</dd><br /><dt>/etc/mailname</dt><br /><dd>This file seems to be generated by the exim4 package. Since we will remove exim4 and install postfix on all machines, we can have postfix regenerate it.</dd><br /><dt>/var/cache/debconf/config.dat</dt><br /><dt>/var/cache/debconf/config.dat-old</dt><br /><dd>These files are used by debconf and contain the answers to the questions asked by debconf. The hostname variable can be changed with the db_set function</dd><br /></dl><br /><br />By changing in the file "/usr/lib/base-config/menu/hostname" <br /><pre><br /># Prompt for the hostname, using the current name, if any, as the default.<br />hostname=<br />LOOPCOUNT=2<br />while [ -z "$hostname" ]; do<br /></pre><br />into<br /><pre><br /># Prompt for the hostname, using the current name, if any, as the default.<br />hostname=myhostname<br />LOOPCOUNT=2<br />while [ -z "$hostname" ]; do<br /></pre><br /><br />I'm able to change both /etc/hostname and uname.<br />But, it would be even better if I could use the debconf value stored in base-config/get_hostname<br />And yet even better if I could ask this question at the start of the installation.<br /><br />For this, I remembered that when I installed <a href='http://www.hands.com/d-i/'>dashslashdash</a> (and of course looked under the hood), a script was installed that messes with the order questions are asked.<br /><br />...<br /><br />After looking through the scripts that make up the installer, I came to the conclusion that working my way around patching netcfg will be more complex than modifying netcfg itself.<br />After all, all I need to do in netcfg is change the priority of 1 question (I hope!)<br /><br />The question now becomes: how do I compile netcfg ? Because it seems to use an old libc version and some libraries that only exist in the installer environment.<br /><br />At first glance, I see no easy way to recompile the netcfg udeb. Maybe I could recompile the entire debian installer, but thats too much work and too much could go wrong.<br /><br />I found the code I need to modify (netcfg-common.c line 520, function netcfg_get_hostname())<br /><pre><br />        debconf_input(client, "high", template);<br /></pre><br /><br />That "high" should be "critical"...<br /><br />I'm considering a binary patch...<br />According to IDE, the instruction I want to modify is located at 0x8049d1d and I have to change 0x804ca63 ("high") to 0x804cada ("critical")<br /><br />So, whipping up xxd:<br /><pre><br />(deepstar/tachyon) /tmp/udebtest/data/bin$ mv netcfg netcfg.old<br />(deepstar/tachyon) /tmp/udebtest/data/bin$ xxd netcfg.old | sed 's/0001d10: 740a c705 8cec 0408 0000 0000 5368 63ca/0001d10: 740a c705 8cec 0408 0000 0000 5368 daca/' | xxd -r &gt; netcfg<br /></pre><br /><br />Well, it still doesn't work.<br />I'm getting tired of this...<br /><br />I did a preliminary test on a real system with 2 disks and 4 networkcards and saw the following problems:<br /><br /><ul><br /><li>netcfg had problems getting online because the wrong networkcard was plugged in. Since each networkcard is connected to another network, netcfg needs to pick the correct networkcard to use. A value of "auto" is not good enough :( Furthermore, since I don't know which order the networkcards are detected, I can't tell in advance which networkcard should be used</li><br /><li>When installing grub, it did not know which disk to install to. Maybe this is some preseed variable ?</li><br /></ul><br /><br />I'm getting more and more convinced that ditching netcfg and writing my own version is the way to go. The postinst script of netcfg just does "exec netcfg". I can replace that with my own code :)<br />I checked what is available in the initrd and found: ifconfig, route, iproute and netcat.<br />That should be enough to do some network configuration magic.<br /><br />After the testsystem was setup, my collegue set it some more and sent me the list of changes.<br />They will be documented on our internal wiki.<br />One thing I should look at, is setting the timezone with tzconfig. Apparently, this is set to a wrong value. I hope there is a debconf variable for this.
  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="/2006/02/16/automated-installations-5/">
        automated installations (5)
      </a>
    </h1>

    <span class="post-date">16 Feb 2006</span>

    I wrote 2 scripts yesterday to unpack and repack the partman-auto_41.udeb package.<br />Being able to change the code allowed me to track down the bug much faster.<br /><br />Next to the 2 scripts to unpack and pack this specific udeb, I also have 2 scripts to mount and umount the initrd (to change the preseed config file) and a s<br />cript to recreate the ISO.<br /><br />These scripts are very specific to my environment, but if you want to have a look at them and modify them to your environment, go ahead :) I'll attach them t<br />o this post.<br /><br />Now for the big news: I patched partman-auto so it works with preseed !<br />To be more precise: the bugs I found earlier were only a part of the problem. After I had changed the code to use the real free diskspace (instead of the cal<br />culated free space, rounded to MB) in the calculations, All 3 partitions were created nicely. However, partman-auto made the last partition a logical one ins<br />tead of a primary one. That made me take a closer look at the whole algorithm and I found out it ALWAYS creates an extended partition at the end of the disk.<br /><br />Why ? In short because after creating all primary partitions, it think it will need to create even more partitions for some reason (that is the bug). It then<br /> looks at the diskspace, decides it's not enough, then deletes the last partition and replaces it with an extended one. The last partition is then created ag<br />ain inside this extended partition.<br /><br />Let's look at the original code and how I patched it:<br /><pre><br />100: while<br />101:     [ "$free_type" = pri/log ] \<br />102:     && echo $scheme | grep '\$primary{' >/dev/null<br />103: do<br />104:     pull_primary<br />105:     set -- $primary<br />106:     open_dialog NEW_PARTITION primary $4 $free_space beginning ${1}000001<br />107:     read_line num id size type fs path name<br />108:     close_dialog<br />109:     if [ -z "$id" ]; then<br />110:    db_progress STOP<br />111:    autopartitioning_failed<br />112:     fi<br />113:     neighbour=$(partition_after $id)<br />114:     if [ "$neighbour" ]; then<br />115:    open_dialog PARTITION_INFO $neighbour<br />116:    read_line x1 new_free_space x2 new_free_type fs x3 x4<br />117:    close_dialog<br />118:     fi<br />119:     if <br />120:    [ -z "$neighbour" -o "$fs" != free \<br />121:      -o "$new_free_type" = primary -o "$new_free_type" = unusable ]<br />122:     then<br />123:    open_dialog DELETE_PARTITION $id<br />124:    close_dialog<br />125:    open_dialog NEW_PARTITION primary $4 $free_space end ${1}000001<br />126:    read_line num id size type fs path name<br />127:    close_dialog<br />128:    if [ -z "$id" ]; then<br />129:        db_progress STOP<br />130:        autopartitioning_failed<br />131:    fi<br />132:    neighbour=$(partition_before $id)<br />133:    if [ "$neighbour" ]; then<br />134:        open_dialog PARTITION_INFO $neighbour<br />135:        read_line x1 new_free_space x2 new_free_type fs x3 x4<br />136:        close_dialog<br />137:    fi<br />138:    if <br />139:        [ -z "$neighbour" -o "$fs" != free -o "$new_free_type" = unusable ]<br />140:    then<br />141:        open_dialog DELETE_PARTITION $id<br />142:        close_dialog<br />143:        break<br />144:    fi<br />145:     fi<br />146:     shift; shift; shift; shift<br />147:     setup_partition $id $*<br />148:     primary=''<br />149:     scheme="$logical"<br />150:     free_space=$new_free_space<br />151:     free_type="$new_free_type"<br />152: done<br />153: <br />154: db_progress STEP 1<br />155: <br />156: foreach_partition '<br />157:     if [ -z "$free_space" ]; then<br />158:         db_progress STOP<br />159:    autopartitioning_failed<br />160:     fi<br />161:     open_dialog PARTITION_INFO $free_space<br />162:     read_line x1 free_space x2 free_type fs x3 x4<br />163:     close_dialog<br />164:     if [ "$fs" != free ]; then<br />165:         free_type=unusable<br />166:     fi<br />167:     case "$free_type" in<br />168:    primary|logical)<br />169:        type="$free_type"<br />170:        ;;<br />171:    pri/log)<br />172:        type=logical<br />173:        ;;<br />174:    unusable)<br />175:             db_progress STOP<br />176:        autopartitioning_failed<br />177:        ;;<br />178:     esac<br />179:     if [ "$last" = yes ]; then<br />180:         open_dialog NEW_PARTITION $type $4 $free_space full ${1}000001<br />181:     else<br />182:         open_dialog NEW_PARTITION $type $4 $free_space beginning ${1}000001<br />183:     fi<br />184:     read_line num id size type fs path name<br />185:     close_dialog<br />186:     if [ -z "$id" ]; then<br />187:         db_progress STOP<br />188:    autopartitioning_failed<br />189:     fi<br />190:     shift; shift; shift; shift<br />191:     setup_partition $id $*<br />192:     free_space=$(partition_after $id)'<br /></pre><br /><br />This time I added nice linenumbers (grep -n "" file) ;)<br /><br />The first while-loop (from 100-152) is where the primary partitions are created.<br />If you don't look at the code between line 120 and 144, the code seems pretty obvious: for every primary partition, create the partition. If there is not eno<br />ugh space, complain and exit.<br />The check that happens on 120-121 tests whether there is some free usable space left.<br />If the check is true (meaning there is no space left), then the script REMOVES the last partition and creates a new extended partition.<br />But this check WILL fail when 3 primary partitions are created, because no space will be left after that.<br /><br />I patched the code in a number of different ways. First, instead of relying on the calculated free diskspace, I recalculate the real free disk space after ea<br />ch partition is added. Next, when a partition wants to be created that is too big for the amount of free diskspace, I trim it down to the available free disk<br />space. Last but not least, Instead of assuming that there has to be free diskspace left after adding each primary partition, I check whether we need to creat<br />e any extra partitions at all. If not, then we don't need any free diskspace and the entire check is skipped.<br /><br />I attached the patch to this post too.<br /><br />I will once again report my findings to the debian-boot list and also to bugs.debian.org.<br /><br />Now that the partition scheme is OK, I want to ask the user for a hostname for the machine.<br />The debconf variable "netcfg/get_hostname" is what I'm looking for, but I can't seem to get debian-installer to ask me that question. Setting it to some valu<br />e works, as well as letting DHCP set it.<br />But debian-installer never asks the question and assumes the default hostname "debian" if no other is picked.<br />The netcfg udeb contains no .config file and the only real executable I can find in there is the program "/bin/netcfg" which is a binary. Patching the source<br /> is something I want to avoid.<br />The reason why the question is not asked is probably because the priority is too low (I'm using priority "critical" in preseed)<br /><br />I'm considering asking the question in some custom config script and maybe setting it myself. Before I can do that I need to know where the hostname is used <br />so that I can reverse whatever debian-installer does with the hostname it picks.<br />I've installed debian with the hostname and networkname "xyz123abc". Much to my surprise, this hostname is not used. Instead, the reverse DNS "dhcp-119" is u<br />sed (and I'm not even using DHCP, just the IP address)<br /><br />Anyway, grepping for "dhcp-119" in all files results in the following list:<br /><pre><br />/etc/hostname<br />/etc/hosts<br />/etc/motd<br />/etc/exim4/update-exim4.conf.conf<br />/etc/ssh/ssh_host_rsa_key.pub<br />/etc/ssh/ssh_host_dsa_key.pub<br />/etc/mailname<br />/var/lib/exim4/config.autogenerated<br />/var/cache/debconf/config.dat<br />/var/cache/debconf/config.dat-old<br />/var/log/exim4/mainlog<br />/var/log/syslog<br />/var/log/auth.log<br />/var/log/debian-installer/cdebconf/questions.dat<br />/var/log/daemon.log<br />/var/log/kern.log<br />/var/log/lpr.log<br />/var/log/debug<br />/var/log/messages<br />/var/spool/mail/mail<br />/var/mail/mail<br /></pre><br /><br />In /var/cache/debconf/config.dat (where the answers to the debconf questions are stored), I find that there is also a variable base-config/get-hostname (mind<br /> the "-" instead of "_")<br />This doesn't do the trick either... Debian insists on calling my machine "dhcp-119".<br /><br />The hostname seems to be set in the base-config udeb. There is also a baseconfig-udeb udeb, which appears to be the second stage installer.<br /><br />This code is probably the culprit (from base-config udeb /usr/lib/base-config/menu/hostname)<br /><pre><br />if [ -z "$currname" ] || [ "$currname" = localhost ]; then<br />        # Check IP addresses of interfaces, try to look up<br />        # using DNS, use that name as default hostname, and<br />        # ask medium priority question if there is a<br />        # default, and high priority question if the default<br />        # is empty.<br />        priority=high<br /><br />        # Make sure there is some good default.  Only change<br />        # the default value, to make it possible to override<br />        # this using the debconf database.<br />        db_set base-config/get-hostname $defaultname<br />        set_default_from_dns<br />else<br />        # Ask at medium priority so the menu item does something if<br />        # manaully selected.<br />        priority=medium<br />        db_set base-config/get-hostname $currname<br />fi<br /><br /></pre>
  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="/2006/02/15/automated-installations-4/">
        automated installations (4)
      </a>
    </h1>

    <span class="post-date">15 Feb 2006</span>

    Now that I know that the bug is in partman-auto, I need to either fix it or work around it.<br />In any case, I will need to replace the udeb.<br /><br />I found a way to unpack the udeb by looking at the sourcecode of udpkg.<br />An udeb is an "ar" package with 3 files (or at least, partman-auto_41.udeb is):<br /><br /><pre><br />(deepstar/tachyon) ~/projects/kulnet-server-setup/cd/pool/main/p/partman-auto$ ar -t partman-auto_41_all.udeb <br />debian-binary<br />control.tar.gz<br />data.tar.gz<br />(deepstar/tachyon) ~/projects/kulnet-server-setup/cd/pool/main/p/partman-auto$ <br /></pre><br /><br />Each of these files can be extracted like so:<br /><pre><br />(deepstar/tachyon) /tmp/udebtest$ udeb=~/projects/kulnet-server-setup/cd/pool/main/p/partman-auto/partman-auto_41_all.udeb; for i in `ar -t $udeb`; do ar -p $udeb $i &gt; $i; done<br />(deepstar/tachyon) /tmp/udebtest$ ls -l<br />total 40<br />-rw-r--r-- 1 deepstar deepstar 28404 2006-02-15 17:28 control.tar.gz<br />-rw-r--r-- 1 deepstar deepstar  7428 2006-02-15 17:28 data.tar.gz<br />-rw-r--r-- 1 deepstar deepstar     4 2006-02-15 17:28 debian-binary<br />(deepstar/tachyon) /tmp/udebtest$ <br /></pre><br /><br />After altering the package, you can recreate the package with<br /><pre><br />(deepstar/tachyon) /tmp/udebtest$ ar -t $udeb<br />debian-binary<br />control.tar.gz<br />data.tar.gz<br />(deepstar/tachyon) /tmp/udebtest$ ls -la<br />(deepstar/tachyon) /tmp/udebtest$ ar -cr partman-auto_41_all.udeb debian-binary control.tar.gz data.tar.gz <br />(deepstar/tachyon) /tmp/udebtest$ <br /></pre><br /><br />The order doesn't seem to matter (from what I see in the sourcecode), but why take the chance.<br />After the udeb is packed again, copy it to the CD and don't forget to change the Packages and Packages.gz files.<br />Normally this is done with dpkg-scanpackages, but since these are udebs, it will probably not work.<br />Being lazy, I do a find on the old md5sum and replace it with the new one.<br /><br />I'll write a script for this as I will need to recreate the package a lot :)
  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="/2006/02/14/automated-installations-3/">
        automated installations (3)
      </a>
    </h1>

    <span class="post-date">14 Feb 2006</span>

    I got a reply from the debian-boot mailinglist that partman-auto indeed has a bug. So I thought about it and decided I would try to find this bug instead of <br />going ahead and writing my own partitioner. For 2 reasons: first, if the bug is fixed, I don't need to write custom software and the current software will be<br /> maintained without me having to put effort in it. Second, if this bug is solved, maybe others will benefit from it too.<br /><br />I must say, while I'm trying to understand this code, I'm learning a few things about shell programming. I'm also noticing the hard way why global variables <br />are a bad thing.<br /><br />I started today's journey by looking at "decode_recipe()". What it does is read a recipe file, parse it and return everything in environment variables. More <br />precise:<br /><br /><pre><br />decode_recipe () {<br />    local ram line word min factor max fs -<br />    unnamed=$(($unnamed + 1))<br />    ram=$(grep ^Mem: /proc/meminfo | { read x y z; echo $y; }) # in bytes<br />    if [ -z "$ram" ]; then<br />        ram=$(grep ^MemTotal: /proc/meminfo | { read x y z; echo $y; })000<br />    fi<br />    ram=$(expr 0000000"$ram" : '0*\(..*\)......$') # convert to megabytes<br />    name="Unnamed.${unnamed}"<br />    scheme=''<br />    line=''<br /></pre><br /><br />In this initialisation, it fetches the amount of RAM you have from /proc/meminfo. "$ram" now contains the amount of megabytes of RAM you have.<br /><br /><pre><br />    for word in $(cat $1); do<br /></pre><br /><br />Now, for start processing each "word" in the file passed as the first argument.<br />This thing is a statemachine. "$word" will contain the last read word, while "$line" will contain the line built up so far.<br /><br /><pre><br />        case $word in<br />            :)<br />                name=$line<br />                line=''<br />                ;;<br /></pre><br /><br />Everything since the last line is stored in "$name" if a ":" is encountered. For example "my little recipe : ..." will store "my little recipe" in "$name"<br /><br /><pre><br />            ::)<br />                db_metaget $line description<br />                if [ "$RET" ]; then<br />                    name=$RET<br />                else<br />                    name="Unnamed.${unnamed}"<br />                fi<br />                line=''<br />                ;;<br /></pre><br /><br />If a "::" is encountered, the name is fetched from the db database. The metaget command fetches the description of a certain database entry.<br /><br /><pre><br />            .)<br /></pre><br /><br />Now we get to the interesting part. When a "." is encountered, that means an entire partition definition is read in and stored in "$line".<br /><br /><pre><br />                # we correct errors in order not to crash parted_server<br />                set -- $line<br /></pre><br /><br />This is an interesting new thing I found :) The "set" command "parses" what is inside "$line" and returns it parts in "$1", "$2", "$3", etc.<br /><br /><pre><br />                if expr "$1" : '[0-9][0-9]*$' >/dev/null; then<br />                    min=$1<br />                elif expr "$1" : '[0-9][0-9]*%$' >/dev/null; then<br />                    min=$(($ram * ${1%?} / 100))<br />                else # error<br />                    min=2200000000 # there is no so big storage device jet<br />                fi<br /></pre><br /><br />The first argument is the minimum size. If it's not a number and not a percentage of RAM, it's set to 2 200 000 000 MB, which is 2200 PB, large enough if you<br /> ask me.<br /><br /><pre><br />                if expr "$2" : '[0-9][0-9]*%$' >/dev/null; then<br />                    factor=$(($ram * ${2%?} / 100))<br />                elif expr "$2" : '[0-9][0-9]*$' >/dev/null; then<br />                    factor=$2<br />                else # error<br />                    factor=$min # do not enlarge the partition<br />                fi<br /></pre><br /><br />The second argument is the socalled "priority", here stored in "$factor". The same rules as for the minimum apply, except that if the priority is invalid, it<br /> is set to the minimum. This should allow me to just enter "x" as a factor and it should still work.<br /><br /><pre><br />                if [ "$factor" -lt "$min" ]; then<br />                    factor="$min"<br />                fi<br /></pre><br /><br />Sanity check: make sure "$factor" is at least as big as "$min"<br /><br /><pre><br />                if expr "$3" : '[0-9][0-9]*$' >/dev/null; then<br />                    max=$3<br />                elif expr "$3" : '[0-9][0-9]*%$' >/dev/null; then<br />                    max=$(($ram * ${3%?} / 100))<br />                else # error<br />                    max=$min # do not enlarge the partition<br />                fi<br /></pre><br /><br />Argument 3 is the maximum size. Same rules apply. If invalid, it's set to the minimum.<br /><br /><pre><br />                if [ "$max" -lt "$min" ]; then<br />                    max="$min"<br />                fi<br /></pre><br /><br />Another sanity check: max should be at least as large the minimum.<br /><br /><pre><br />                case "$4" in # allow only valid file systems<br />                    ext2|ext3|xfs|reiserfs|jfs|linux-swap|fat16|fat32|hfs)<br />                        fs="$4"<br />                        ;;<br />                    *)<br />                        fs=ext2<br />                        ;;<br />                esac<br /></pre><br /><br />The 4th argument is the type of partition. If it's not in the list, it's set to ext2.<br /><br /><pre><br />                shift; shift; shift; shift<br />                line="$min $factor $max $fs $*"<br />                if [ "$scheme" ]; then<br />                    scheme="${scheme}${NL}${line}"<br />                else<br />                    scheme="$line"<br />                fi<br />                line=''<br />                ;;<br /></pre><br /><br />"shift" removes an argument from the input. 4 times shift removes "$1" "$2" "$3" and "$4", leaving everything behind "$4" in "$*". Now a "cleaned up" "$line"<br /> is created with the sanitized values from above and the rest of the line ($*). It is stored on a new line in "$scheme". This is important. "$scheme" contain<br />s a multiline version of the recipe. (I've peeked ahead) In the future, the recipe will be read in line per line by setting $IFS to "\n".<br /><br /><pre><br />            *)<br />                if [ "$line" ]; then<br />                    line="$line $word"<br />                else<br />                    line="$word"<br />                fi<br />        esac<br /></pre><br /><br />For any other word (not ":" "::" or "."), the word is glued at the end of the current "$line".<br />This completes the circle :)<br /><br /><pre><br />    done<br />}<br /></pre><br /><br />And that was "decode_recipe()".<br />Afaik, this piece of code looks correct. It does what is expected and does some error correction in the process.<br />After this function, the following variables will have been set:<br /><br /><dl><br /><dt>$name</dt><br /><dd>The name of the scheme</dd><br /><dt>$scheme</dt><br /><dd>The parsed version of the recipe. It's a multiline string (separated by \n) with a partition definition on each line</dd><br /></dl><br /><br />Contrary to what I expected, "$ram" is not kept outside of this function (notice the "local ram ..." at the start of the function)<br /><br /><br />The next function I encountered (alot) is the "foreach_partition()" function. It's pretty clear what this function does, but I decided to look at it anyway b<br />ecause it could contain weirdness.<br /><br /><pre><br />foreach_partition () {<br />    local - doing IFS partition former last<br />    doing=$1<br />    IFS="$NL"<br />    former=''<br />    for partition in $scheme; do<br />        restore_ifs<br />        if [ "$former" ]; then<br />            set -- $former<br />            last=no<br />            eval "$doing"<br />        fi<br />        former="$partition" <br />    done<br />    if [ "$former" ]; then<br />        set -- $former<br />        last=yes<br />        eval "$doing"<br />    fi<br />}<br /></pre><br /><br />This looks pretty innocent. Like I said, the partitions in "$scheme" are separated by "\n". In this function, the separate partitions are loaded in "$partiti<br />on" one by one. The variable "$last" is set to "no" for all except the last partition, where it is set to "yes". Then "$doing" is eval'ed.<br /><br />So, the first argument of "foreach_partition()" is the function you want to call on each partition. The partition details (min factor max fs and the rest) ar<br />e passed as "$1", "$2", "$3", ... etc.<br />Furthermore, there is a variable "$last" which indicates whether the current partition is the last one.<br /><br />Interesting to note is that the IFS is not restored for the last partition. I'm not sure whether this is by design or if its a bug. (Notice the "restore_ifs(<br />)" call in the for loop)<br /><br />[after checking]<br />It's not a bug :) The code works as expected. The only time it would not work is if there was nothing in "$scheme", but then "$former" would not be set eithe<br />r.<br /><br />Both "open_dialog()" and "close_dialog()" are interesting as well as it seems they call the parted_server. On closer inspection, "open_dialog()" writes a com<br />mand in a fifo (destination parted_server) and reads the result from another fifo (origin parted_server). It then handles any errors that appear. "close_dial<br />og()" cleans up the fifo's.<br /><br />The fifo's are called /var/lib/partman/infifo and /var/lib/partman/outfifo and are opened on descriptor 6 and 7 respectively.<br /><br />The "read_line()" function reads is a wrapper around "read()" that reads from the outfifo (the output of parted_server)<br /><br />Now here is a promising function: "pull_primary()"<br /><br /><pre><br />pull_primary () {<br />    primary=''<br />    logical=''<br />    foreach_partition '<br />        if<br />            [ -z "$primary" ] \<br />            && echo $* | grep '\''\$primary{'\'' >/dev/null<br />        then<br />            primary="$*"<br />        else<br />            if [ -z "$logical" ]; then<br />                logical="$*"<br />            else<br />                logical="${logical}${NL}$*"<br />            fi<br />        fi'<br />}<br /></pre><br /><br />This function acucmulates data in 2 variables: "$primary" and "$logical". Both are empty at start.<br />Then, it goes over every partition. If it's a primary partition, it is put in "$primary". Otherwise it's appended to "$logical".<br /><br />Now what is interesting, is that only the first primary partition is put in "$primary". The rest is appended to "$logical".<br />Tests confirm it.<br /><br />[At first glance, this seems to be an unfortunate namingscheme for the variables, nothing more.]<br /><br />Some more functions: "partition_before()" and "partition_after()"<br />Both functions return the ID of the partition coming before or after another partition ID.<br />The sort order is defined by what "open_dialog PARTITIONS" returns.<br />The parted_server calls "ped_disk_next_partition()" over and over. I'm guessing it reads the ID's in order then. Now what is outputed is interesting:<br /><pre><br />/* Returns informational string about `part' from `disk'.  Format:*/<br />/* Number<TAB>id<TAB>length<TAB>type<TAB>fs<TAB>path<TAB>name */<br />char *<br />partition_info(PedDisk *disk, PedPartition *part)<br />{<br />        char const *type;<br />        char const *fs;<br />        char *path;<br />        char const *name;<br />        char *result;<br />        assert(disk != NULL && part != NULL);<br />        if (PED_PARTITION_FREESPACE & part->type) {<br />                bool possible_primary = possible_primary_partition(disk, part);<br />                bool possible_logical = possible_logical_partition(disk, part);<br />                if (possible_primary) <br />                        if (possible_logical)<br />                                type = "pri/log";<br />                        else<br />                                type = "primary";<br />                else if (possible_logical)<br />                        type = "logical";<br />                else<br />                        type = "unusable";<br />        } else if (PED_PARTITION_LOGICAL & part->type)<br />                type = "logical";<br />        else<br />                type = "primary";<br /><br />        if (PED_PARTITION_FREESPACE & part->type)<br />                fs = "free";<br />        else if (PED_PARTITION_METADATA & part->type)<br />                fs = "label";<br />        else if (PED_PARTITION_EXTENDED & part->type)<br />                fs = "extended";<br />        else if (NULL == (part->fs_type))<br />                fs = "unknown";<br />        else<br />                fs = part->fs_type->name;<br />        if (0 == strcmp(disk->type->name, "loop")) {<br />                path = strdup(disk->dev->path);<br />/*         } else if (0 == strcmp(disk->type->name, "dvh")) { */<br />/*                 PedPartition *p; */<br />/*                 int count = 1; */<br />/*                 int number_offset; */<br />/*                 for (p = NULL; */<br />/*                      NULL != (p = ped_disk_next_partition(disk, p));) { */<br />/*                         if (PED_PARTITION_METADATA & p->type) */<br />/*                                 continue; */<br />/*                         if (PED_PARTITION_FREESPACE & p->type) */<br />/*                                 continue; */<br />/*                         if (PED_PARTITION_LOGICAL & p->type) */<br />/*                                 continue; */<br />/*                         if (part->num > p->num) */<br />/*                                 count++; */<br />/*                 } */<br />/*                 path = ped_partition_get_path(part); */<br />/*                 number_offset = strlen(path); */<br />/*                 while (number_offset > 0 && isdigit(path[number_offset-1])) */<br />/*                         number_offset--; */<br />/*                 sprintf(path + number_offset, "%i", count); */<br />        } else {<br />                path = ped_partition_get_path(part);<br />        }<br />        if (ped_disk_type_check_feature(part->disk->type,<br />                                        PED_DISK_TYPE_PARTITION_NAME)<br />            && ped_partition_is_active(part))<br />                name = ped_partition_get_name(part);<br />        else<br />                name = "";<br />        asprintf(&result, "%i\t%lli-%lli\t%lli\t%s\t%s\t%s\t%s",<br />                 part->num,<br />                 (part->geom).start * PED_SECTOR_SIZE,<br />                 (part->geom).end * PED_SECTOR_SIZE + PED_SECTOR_SIZE - 1,<br />                 (part->geom).length * PED_SECTOR_SIZE, type, fs, path, name);<br />        free(path);<br />        return result;<br />}<br /></pre><br /><br />Notice the "pri/log" stuff. I suspect it stirring trouble...<br /><br />When I execute the PARTITIONS command myself in vmware by doing:<br /><pre><br />~ # cd /var/lib/partman<br />/var/lib/partman # echo PARTITIONS =dev=scsi=host0=bus0=target0=lun0=disc > infifo<br />/var/lib/partman # cat outfifo<br />OK<br />1        32256-2048094719        2048062464       primary     linux-swap    /dev/scsi/host0/bus0/target0/lun0/part1<br />2        2048094720-2113896959   65802240         primary     ext3          /dev/scsi/host0/bus0/target0/lun0/part2<br />-1       2113896960-5362882559   3248985600       pri/log     free          /dev/scsi/host0/bus0/target0/lun0/part-1<br /></pre><br /><br />(not copy pasted ;)<br /><br />The id "-1" on the 3rd line is interesting. also the "pri/log" and "free".<br /><br />After some looking trough logs, I believe the "-1" stands for empty diskspace.<br />I find the following text in the logs (partman has logs!!!!!! look in /var/log/partman):<br /><pre><br />/bin/perform_recipe: IN: NEW_PARTITION =dev=scsi=host0=bus0=target0=lun0=disc primary ext3 2113896960-5362882559 beginning 3255600001<br />parted_server: Read command: NEW_PARTITION<br />parted_server: command_new_partition()<br />parted_server: Note =dev=scsi=host0=bus0=target0=lun0=disc as changed<br />parted_server: Opening outfifo<br />parted_server: requested partition with type primary<br />parted_server: requested partition with file system ext3<br />parted_server: add_primary_partition(disk(10485760),4128705-10488080)<br />parted_server: OUT: Error<br /><br />parted_server: OUT: Can't have a partition outside the disk!<br /><br />parted_server: OUT:<br /><br />parted_server: OUT: Cancel<br />...<br /></pre><br /><br />I think I may have tripped over the bug here.<br />According to parted_server, there is 3248985600 bytes free for a new partition, but partman wants to create a partition of 3256000001 bytes.<br /><br />I tried with the following sizes and results:<br /><br />3253000000 OK<br />3255000000 NOK<br />3254000000 OK<br />3254500000 OK<br />3254800000 OK<br />3254900000 NOK<br />3254850000 NOK<br />3254830000 NOK<br />3254815000 NOK<br />3254807500 OK<br />3254810000 OK<br />3254812500 NOK<br />3254811250 OK<br />3254811850 OK<br />3254812000 OK<br />3254812250 NOK<br />3254812125 OK<br />3254812200 NOK<br />3254812180 NOK<br />3254812150 OK<br />3254812165 NOK<br />3254812160 NOK<br />3254812155 OK<br />3254812157 OK<br />3254812159 OK<br /><br />I'm not sure where the 3254812159 (max partition size) - 3248985600 (free on disk) = 5826559 bytes come from ?<br /><br />In any case, since the commandline contains the word "beginning", the points of origin are limited to 2 places in the perform_recipe script.<br /><br />And since we defined it as primary, it is most likely that the problem is located here :<br /><br /><pre><br />...<br />while<br />    [ "$free_type" = pri/log ] \<br />    && echo $scheme | grep '\$primary{' >/dev/null<br />do<br />    pull_primary<br />    set -- $primary<br />    open_dialog NEW_PARTITION primary $4 $free_space beginning ${1}000001<br />    read_line num id size type fs path name<br />...<br /></pre><br /><br />The "$free_space" variable is calculated from the last pass through the while loop (when sda2 was created).<br /><br /><pre><br />...<br />    neighbour=$(partition_after $id)<br />    if [ "$neighbour" ]; then<br />        open_dialog PARTITION_INFO $neighbour<br />        read_line x1 new_free_space x2 new_free_type fs x3 x4<br />        close_dialog<br />    fi<br />    if<br />        [ -z "$neighbour" -o "$fs" != free \<br />          -o "$new_free_type" = primary -o "$new_free_type" = unusable ]<br />    then<br /><br />... [we don't get in here]<br /><br />    fi<br />    shift; shift; shift; shift<br />    setup_partition $id $*<br />    primary=''<br />    scheme="$logical"<br />    free_space=$new_free_space<br />    free_type="$new_free_type"<br /></pre><br /><br />"partition_after()" returns "2113896960-5362882559" and it is stored in "$neighbour".<br />Then some PARTITION_INFO is queried for this neighbour. The following variables are set:<br /><br /><dl><br /><dt>$new_free_space</dt><br /><dd>2113896960-5362882559</dd><br /><dt>$new_free_type</dt><br /><dd>pri/log</dd><br /><dt>$fs</dt><br /><dd>free</dd><br /></dl><br /><br />The condition of the if() doesn't match, so that can be skipped. What remains is "setup_partition()" and some variable transfers.<br />Although "setup_partitions()" seems to contain some interesting code (!), it does not alter any non-local variables.<br /><br />We now know where all variables come from in this line:<br /><pre><br />open_dialog NEW_PARTITION primary $4 $free_space beginning ${1}000001<br /></pre><br /><br /><dl><br /><dt>$4</dt><br /><dd>This is the 4th argument of the partition definition of our current partition to create. It's value is "ext3"</dd><br /><dt>$free_space</dt><br /><dd>This is the value stored in $new_free_space of the previous while()-run. The value is obtained from a call to "partition_after()". It's value is 21138969<br />60-5362882559</dd><br /><dt>${1}</dt><br /><dd>This is the first argument of the partition definition. It's the minimum size of the partition, but it went through a number of calculations and election<br />s and actually contains the size to create the partition with.</dd><br /></dl><br /><br />The minimum size is calculated as being 3256 MB:<br />The entire disk is 5368709120 bytes. This is rounded to 5368MB.<br />Then we lose 2048MB and 64MB and a potential 500MB, which gives 2756MB unallocated.<br /><br />We enter the calculation loop with the following data:<br /><br />sda1: 2048 0 2048<br />sda2: 64 0 64<br />sda3: 500 0 1000000000<br />The second number is the "factor" calculated from the "priority"<br /><br />free_space is 5368MB and unallocated is 2756.<br /><br /><pre><br />oldscheme=''<br />while [ "$scheme" != "$oldscheme" ]; do<br />    oldscheme="$scheme"<br />    factsum=$(factor_sum)<br />    unallocated=$(($free_size - $(min_size)))<br />    if [ $unallocated -lt 0 ]; then<br />        unallocated=0<br />    fi<br />    scheme=$(<br />        foreach_partition '<br />            local min fact max newmin<br />            min=$1<br />            fact=$2<br />            max=$3<br />            shift; shift; shift<br />            newmin=$(($min + $unallocated * $fact / $factsum))<br />            if [ $newmin -le $max ]; then<br />                echo $newmin $fact $max $*<br />            else<br />                echo $max 0 $max $*<br />            fi'<br />    )<br />    echo "XXX[$unallocated]"<br />    echo "[$oldscheme][$scheme]";<br />    echo<br />done<br /></pre><br /><br />The key formula here is <code>newmin=$(($min + $unallocated * $fact / $factsum))</code><br /><br />For sda1 and sda2, this doesn't change anything because fact is 0.<br />For sda3, unallocated is 2756, fact is 100 and factsum is also 100 (and I suppose factsum will always be 100 in any case, since it's 100%)<br />So the minimum size for sda3 is calculated to be 500 + 2756*100/100, which is 3256MB<br /><br />OK, let's look at the real data again, because I've been using simulated data.<br />At the start of perform_recipe, the "$free_size" is calculated by means of a PARTITION_INFO command. The result is 5368709120 bytes, rounded to 5368MB.<br /><br />By looking at how partitions are created, I notice an odd thing:<br />The first partition (2048MB) is created starting from offset 32256 and going to 2048094719 having a reported size of 2048062464 bytes (asked for 2048000001 b<br />ytes). The second one is created from 2048094720-2113896959 with reported size of 65802240 bytes (asked for 64000001 bytes).<br />The last partition is obviously not created with a requested size of 3256000001 bytes)<br /><br />The reported sizes added together: 2048062464 + 65802240 + 3254812159 = 5368676863<br />(The 3254812159 is the maximum amount we were allowed to use for the 3rd partition)<br />The disk is 5368709120 bytes, so what remains (full disk - whats in use) = 5368709120 - 5368676863 = 32257 bytes.<br /><br />This happens to be the amount missing from the front of the disk. Probably not coincidence.<br />Maybe the partman-auto author overlooked this.<br /><br />Now that I think of it, 32KB is really not that much... but maybe enough to throw everything out of whack. On the other side, the partition only has to be 1 <br />byte to big for parted_server to fail.<br />Considering that there is a lot of going back and forward between bytes and MB and that megabytes are not calculated cleanly (1000000 bytes instead of 1024*1<br />024), I could be dealing with rounding errors.
  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="/2006/02/13/automated-installations-2/">
        automated installations (2)
      </a>
    </h1>

    <span class="post-date">13 Feb 2006</span>

    I signed up for the debian-boot mailinglist and asked my question. No answer yet.<br />In a futile attempt to find more answers I tried google and found the <a href='http://wiki.debian.org/DebianInstaller/PartmanPrc'>Partman Recipe Calculator (PRC)</a>. It doesn't work out of the box for python 2.3.5 but if you change line 114 from<br /><code><br />pie = gdchart.Pie()<br /></code><br />to<br /><code><br />pie = gdchart.Pie3D()<br /></code><br /><br />It will work nicely.<br />Since my recipe generated a nice piechart without any funny complications, I can only assume that my recipe is correct. This also implies that there is a bug in partman-auto...<br /><br />Since I'm dumb enough to try and find this bug, here is my progress so far:<br /><br />I believed (falsely) that partman-auto only used (ba)sh to create the partitions and speculated that it was using some type of kernel interface to create them.<br />After closer inspection, it seems that partman-auto makes use of the partman udeb. This last udeb has a "parted_server" daemon written in C, that seems to take of care of most of the lowlevel stuff.<br /><br />I tracked the code as follows:<br /><br />There exists a function <code>add_primary_partition()</code> which gets called by <code>command_new_partition()</code> if the first passed word is "primary". <code>command_new_partition()</code> is called by <code>main_loop()</code> when it receives a "NEW_PARTITION" command. Since "NEW_PARTITION" is nowhere else in the Partman udeb, I looked inside Partman-auto and found that it gets used in the "perform_recipe" script.<br /><br />This last script has 4 references to "NEW_PARTITION":<br /><code><br />106: open_dialog NEW_PARTITION primary $4 $free_space beginning ${1}000001<br />125: open_dialog NEW_PARTITION primary $4 $free_space end ${1}000001<br />180: open_dialog NEW_PARTITION $type $4 $free_space full ${1}000001<br />182: open_dialog NEW_PARTITION $type $4 $free_space beginning ${1}000001<br /></code><br /><br />The first 2 make a call with the "primary" argument hardcoded. So I assume they are not what I should look at. The interesting lines are 180 and 182.<br /><br />The "$type" variable is set as follows:<br /><pre><br />    case "$free_type" in<br />        primary|logical)<br />            type="$free_type"<br />            ;;<br />        pri/log)<br />            type=logical<br />            ;;<br />        unusable)<br />            db_progress STOP<br />            autopartitioning_failed<br />            ;;<br />    esac<br /></pre><br /><br />...<br />After looking for the answer long and hard, I've come to the conclusion that I'm on the outer edge of Debian knowledge. This means noone seems to know the answer, or noone wants to answer me. I prefer to believe the former because that makes noone an asshole.<br /><br />Partman-auto as it is, might do well for Debian installations aimed at newbies, but it sucks when you have to use it with preseed. I've tried about every recipe I think could work. In the end I even tried creating a 4th partition with the idea that I could delete it afterwards. No such luck.<br /><br />While I was looking around in the booted debian installer during the failed installation, I noticed that sfdisk is installed.<br />I might drop the entire partman thing and just create partitions myself with sfdisk and some wrapper.<br />With sfdisk you just say: <br /><code><br />(echo ",2048,82"; echo ",64,83"; echo ",,83") | sfdisk -uM /dev/discs/disc0/disc<br /></code><br /><br />Where ",2048,82" denotes: 2048 MB type 82 (swap), ",64,83": 64MB type 83 (ext2) and ",,83": the rest type 83 (ext2)<br />(In case you are wondering, -uM means: interpret sizes as MB)<br /><br />So, all I need now is a handy way to get the amount of RAM and I'm set :)<br />And seeing as the "free" command exists, I can't see further obstacles!<br />
  </div>
  
</div>

<div class="pagination">
  
    <a class="pagination-item older" href="/page88">Older</a>
  
  
    
      <a class="pagination-item newer" href="/page86">Newer</a>
    
  
</div>

    </div>

  </body>
</html>
