<!DOCTYPE html>
<html lang="en-us">

  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    
      Configuring ISA with Powershell: more examples &middot; Singularity.be
    
  </title>

  <!-- CSS -->
  <link rel="stylesheet" href="/public/css/poole.css">
  <link rel="stylesheet" href="/public/css/syntax.css">
  <link rel="stylesheet" href="/public/css/hyde.css">
  <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface">

  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/public/apple-touch-icon-144-precomposed.png">
                                 <link rel="shortcut icon" href="/public/favicon.ico">

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml">
</head>


  <body>

    <div class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <h1>
        <a href="/">
          Singularity.be
        </a>
      </h1>
      <p class="lead">Steven Van Acker's blog</p>
    </div>

    <nav class="sidebar-nav">
      <a class="sidebar-nav-item" href="/">Home</a>

      

      
      
        
          
        
      
        
          
            <a class="sidebar-nav-item" href="/about/">About</a>
          
        
      
        
          
        
      
        
      
        
          
        
      
        
          
            <a class="sidebar-nav-item" href="/projects/">Projects</a>
          
        
      
        
          
            <a class="sidebar-nav-item" href="/publications/">Publications</a>
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
    </nav>

    <!-- <p>&copy; 2016. All rights reserved.</p> -->
  </div>
</div>


    <div class="content container">
      <div class="post">
  <h1 class="post-title">Configuring ISA with Powershell: more examples</h1>
  <span class="post-date">23 Apr 2008</span>
  <!-- StevensBlogSpotFilterThing<br /><a href="//2008/04/01/configuring-isa-through-powershell-some/">Some time ago</a> I posted a few examples of Powershell scripts to configure ISA. Now that I look back at it, I saw it was posted on April 1st. Rest assured, those examples are no joke :)<br /><br />It's now about 3 weeks later and time for another update.<br /><br />Before I paste the scripts, some explanation is needed. <br /><br />First of all, all my scripts are processed by a template engine before they are executed. We currently have 3 domains (2 experimental and 1 production) where 2 ISA servers and CSS server need to be setup.<br />I want the setup to be identical, except for things like SSL certificates, IP addresses and usernames and such. All of those variables are placed in the scripts (and INIfiles not shown here) by the template engine. Such variables can be recognized by the "$$$" in front and to the back of them. For example: $$$__DOMAIN$$$ will be replaced with the name of the domain that is currently being installed in.<br /><br />Next, What do these scripts do ?<br /><br /><dl><br /><dt>access_rule_for_scom.ps1</dt><br /><dd>Creates an access rule for the SCOM (MOM) monitoring server. This will allow connections from the ISA server to the SCOM server on some port.</dd><br /><dt>access_rule_for_sqllogging.ps1</dt><br /><dd></dd><br /><dt>add_nagios_to_remote_monitoring.ps1</dt><br /><dd>Adds our Nagios server to the "Remote Monitoring Computers" computerset defined in some other script.</dd><br /><dt>allow_mgmt_from_css.ps1</dt><br /><dd>Adds the CSS server to the Remote Management Computers computerset, because otherwise, it won't be able to keep a look on the ISA servers (when having the CSS on a different physical machine than the ISA servers)</dd><br /><dt>allow_mgmt_from_subnet.ps1</dt><br /><dd>Adds a specific subnet to the Remote Management Computers computerset, as to not lock us out when we install from a different location than the usual one</dd><br /><dt>allow_RDP_from_kulnetnat.ps1</dt><br /><dd>This one adds our NAT to the "Enterprise Remote Management Computers" computerset</dd><br /><dt>configure_intra_array_addresses.ps1</dt><br /><dd>Configures the intra-array IP addresses used by the ISA servers. We use a separate network for this, with their own IP addresses. Beware !! Both ISA servers need to be installed and joined in the ISA array before you can configure these IP addresses. Why ? Well because joining the ISA server in the array will create some entries in the CSS that can't be created otherwise (I think)</dd><br /><dt>create_new_array.ps1</dt><br /><dd>Create a fresh array. At first, I used the "InstallNewArrayAndServer.ini" configfile provided with the ISA installation files, for unattended installation. But after a while I was sick of waiting untill an ISA was installed to configure the CSS. This script takes care of that. It will create an array in the CSS and you can start configuring it, even before any ISA servers are joined.</dd><br /><dt>create_weblisteners.ps1</dt><br /><dd>Here, I've experimented with a powershell function. The function creates a weblistener the way we want it and it is then called for every weblistenenr we want to add. We use a separate IP per certificate, and 1 IP per weblistener. Authentication method differs depending to the weblistener.</dd><br /><dt>debug_access_rule_allow_all.ps1</dt><br /><dd>Creates a debug accessrule allowing all traffic from the ISA to the Internal network. It is disabled by default.</dd><br /><dt>enable_ICMP_from_remote_monitoring.ps1</dt><br /><dd>Adds the "Remote Monitoring Computers" computerset to the ICMP system policy rule. System policy rules are configured differently from other policy rules, so it was sortof interesting to get this working.</dd><br /><dt>enable_NLB.ps1</dt><br /><dd>Enable Network Load Balancing on the External network and add all the IPs we will use in the weblisteners. We're also using unicast NLB because we're too lazy to configure our network infrastructure for multicast NLB.</dd><br /><dt>enable_sqllogging.ps1</dt><br /><dd>Configures the Logging settings to log to an external SQL server. We also don't want ISA to stop working when SQL fails, so this script disables that.</dd><br /><dt>publish_all_https.ps1</dt><br /><dd>This script created all webpublishing rules, using the weblisteners created in an earlier script. Again, a function is used to keep the code short. This script also shows how to reorder rules.</dd><br /><dt>publish_imaps_pops.ps1</dt><br /><dd>Publish IMAPs and POPs</dd><br /><dt>select_network_template_and_default_policy.ps1</dt><br /><dd>Select the "Edge Firewall" network template and set the default policy to "block all"</dd><br /></dl><br /><br />Here they are, copied directly from my screen:<br /><br /><b>access_rule_for_scom.ps1</b><br /><br /><pre><br /># find our little array, reference it from $arr<br />$root = new-object -comobject "FPC.Root" -strict<br />$arr = $root.Arrays | select-object -first 1<br /><br /># we want to allow connections to SCOM from the ISA server<br /># First, lets define a group "Remote Monitoring Computers" that will hold all SCOM computers<br />$newset = $arr.RuleElements.ComputerSets.Add("Remote Monitoring Computers")<br /><br /># Now we add an IP address in it, and name it "SCOM"<br /># We only have 1 SCOM computer at the moment.<br />$newset.Computers.Add("SCOM","$$$SCOM_IP_ADDRESS$$$")<br /><br /># save this new computer set<br />$arr.save()<br /><br /># create a new protocol definition<br />$proto = $arr.RuleElements.ProtocolDefinitions.Add("System Center Operations Manager 2007 agent")<br /># outbound to port 5723<br />$proto.PrimaryConnections.AddTCP(1, 5723, 5723)<br />$proto.save()<br /><br />$scomrule = $arr.ArrayPolicy.PolicyRules.AddAccessRule("Outbound to SCOM")<br /><br /># Allow<br />$scomrule.Action = 0<br /># only the following selected protocols ...<br />$scomrule.AccessProperties.ProtocolSelectionMethod = 1<br /># ... The SCOM 2007 protocol<br />$scomrule.AccessProperties.SpecifiedProtocols.Add("System Center Operations Manager 2007 agent", 0)<br /># From Local Host<br />$scomrule.SourceSelectionIPs.Networks.Add("Local Host", 0)<br /># To Remote Monitoring Computers<br />$scomrule.AccessProperties.DestinationSelectionIPs.ComputerSets.Add("Remote Monitoring Computers", 0)<br /># By All Users<br />$scomrule.AccessProperties.UserSets.Add("All Users", 0)<br /><br />$scomrule.save()<br /></pre><br /><br /><b>access_rule_for_sqllogging.ps1</b><br /><br /><pre><br /># find our little array, reference it from $arr<br />$root = new-object -comobject "FPC.Root" -strict<br />$arr = $root.Arrays | select-object -first 1<br /><br /><br /># First, create a new protocol definition<br />$proto = $arr.RuleElements.ProtocolDefinitions.Add("SQL Cluster")<br /># outbound to SQL server port<br />$proto.PrimaryConnections.AddTCP(1, $$$SQL_SERVER_PORT$$$, $$$SQL_SERVER_PORT$$$)<br />$proto.save()<br /><br /># Next, create a computerset for the SQL cluster<br />$newset = $arr.RuleElements.ComputerSets.Add("SQL Server Cluster")<br />$newset.Computers.Add("SQL Server for ISA","$$$SQL_SERVER_IP_ADDRESS$$$")<br />$newset.save()<br /><br /><br />$sqlrule = $arr.ArrayPolicy.PolicyRules.AddAccessRule("Outbound to SQL Cluster")<br /><br /># Allow<br />$sqlrule.Action = 0<br /># only the following selected protocols ...<br />$sqlrule.AccessProperties.ProtocolSelectionMethod = 1<br /># ... The SQL Cluster protocol<br />$sqlrule.AccessProperties.SpecifiedProtocols.Add("SQL Cluster", 0)<br /># From Local Host<br />$sqlrule.SourceSelectionIPs.Networks.Add("Local Host", 0)<br /># To SQL Cluster<br />$sqlrule.AccessProperties.DestinationSelectionIPs.ComputerSets.Add("SQL Server Cluster", 0)<br /># By All Users<br />$sqlrule.AccessProperties.UserSets.Add("All Users", 0)<br /><br />$sqlrule.save()<br /></pre><br /><br /><b>add_nagios_to_remote_monitoring.ps1</b><br /><br /><pre><br /># find our little array, reference it from $arr<br />$root = new-object -comobject "FPC.Root" -strict<br />$arr = $root.Arrays | select-object -first 1<br /><br />$set = $arr.RuleElements.ComputerSets | where-object {$_.name -eq "Remote Monitoring Computers"}<br />$set.Computers.Add("KulNet Nagios","$$$NAGIOS_IP_ADDRESS$$$")<br />$set.save()<br /></pre><br /><br /><b>allow_mgmt_from_css.ps1</b><br /><br /><pre><br /># find our little array, reference it from $arr<br />$root = new-object -comobject "FPC.Root" -strict<br />$arr = $root.Arrays | select-object -first 1<br /><br /><br />$mgmt = $arr.RuleElements.ComputerSets | where-object { $_.name -eq "Remote Management Computers" }<br />$mgmt.Computers.Add("CSS1","$$$STORAGESERVER_IP$$$")<br />$arr.save()<br /></pre><br /><br /><b>allow_mgmt_from_subnet.ps1</b><br /><br /><pre><br /># find our little array, reference it from $arr<br />$root = new-object -comobject "FPC.Root" -strict<br />$arr = $root.Arrays | select-object -first 1<br /><br /><br />$mgmt = $arr.RuleElements.ComputerSets | where-object { $_.name -eq "Remote Management Computers" }<br />$mgmt.Subnets.Add("Management Subnet","$$$MANAGEMENT_SUBNET$$$", "$$$MANAGEMENT_SUBNET_MASK$$$")<br />$arr.save()<br /></pre><br /><br /><b>allow_RDP_from_kulnetnat.ps1</b><br /><br /><pre><br /># find our little array, reference it from $arr<br />$root = new-object -comobject "FPC.Root" -strict<br /><br />$remotemgmt = $root.Enterprise.RuleElements.ComputerSets | where-object { $_.name -eq "Enterprise Remote Management Computers" }<br /><br />$remotemgmt.Computers.add("$$$KULNET_NAT_NAME$$$", "$$$KULNET_NAT_IP$$$")<br />$remotemgmt.Computers.save()<br /></pre><br /><br /><b>configure_intra_array_addresses.ps1</b><br /><br /><pre><br /># find our little array, reference it from $arr<br />$root = new-object -comobject "FPC.Root" -strict<br />$arr = $root.Arrays | select-object -first 1<br /><br /># let NLB communication go over the specialised network<br />$isa1 = $arr.Servers | Where-Object { $_.name -eq "$$$__HOST_ISA1_NAME$$$" }<br />$isa1.IntraArrayAddress = "$$$__HOST_ISA1_HB$$$"<br />$isa1.save()<br /><br />$isa2 = $arr.Servers | Where-Object { $_.name -eq "$$$__HOST_ISA2_NAME$$$" }<br />$isa2.IntraArrayAddress = "$$$__HOST_ISA2_HB$$$"<br />$isa2.save()<br /><br /></pre><br /><br /><b>create_new_array.ps1</b><br /><br /><pre><br />$root = new-object -comobject "FPC.Root" -strict<br /><br />$arr = $root.Arrays.add("$$$ARRAY_NAME$$$")<br />$internal = $arr.NetworkConfiguration.Networks | Where-Object {$_.name -eq "Internal"}<br />$internal.IpRangeSet.Add("$$$ARRAY_INTERNALNET_START$$$","$$$ARRAY_INTERNALNET_END$$$")<br /><br />$root.save()<br /></pre><br /><br /><b>create_weblisteners.ps1</b><br /><br /><pre><br />$fpcSpecifiedIPAddress = 2<br /><br />$fpcRedirectHTTPAsHTTPSDisabled = 0<br />$fpcRedirectHTTPAsHTTPSIfAuthenticated = 1<br />$fpcRedirectHTTPAsHTTPSAlways = 2<br /><br />function spawnWebListener([string]$name, <br />                          [string]$ip, <br />                          [string]$cn, <br />                          [boolean]$basicauth=$true, <br />                          [boolean]$digest=$false, <br />                          [boolean]$integrated=$false) {<br />    $hash = (dir cert:\localmachine\my | where-object { $_.subject -like "CN=$cn*" }).getCertHash()<br />    <br />    $nwl = $arr.RuleElements.WebListeners.add($name)<br /><br />    $res = $nwl.IPsOnNetworks.Add("External", $fpcSpecifiedIPAddress, $ip)<br />    $nwl.Properties.TCPPort = 80<br />    $nwl.Properties.RedirectHTTPAsHTTPS = $fpcRedirectHTTPAsHTTPSAlways<br />    $nwl.Properties.SSLPort = 443<br />    $res = $nwl.Properties.AppliedSSLCertificates.Add([byte[]]($hash))<br />    $nwl.Properties.BasicAuthentication = $basicauth<br />    $nwl.Properties.DigestAuthentication = $digest<br />    $nwl.Properties.IntegratedWindowsAuthentication = $integrated<br />    $nwl.Properties.AlwaysAuthenticate = $true<br />    $nwl.save()<br /><br />    return $nwl<br />}<br /><br /><br /># find our little array, reference it from $arr<br />$root = new-object -comobject "FPC.Root" -strict<br />$arr = $root.Arrays | select-object -first 1<br /><br /><br />$wl = spawnWebListener "ActiveSync WebListener"       "$$$ISA_EXTERNAL_NLB_ACTIVESYNC_IP$$$"      "$$$ISA_EXTERNAL_NLB_ACTIVESYNC_NAME$$$"       $false $true  $true<br />$wl = spawnWebListener "Sharepoint WebListener"       "$$$ISA_EXTERNAL_NLB_SHAREPOINT_IP$$$"      "$$$ISA_EXTERNAL_NLB_SHAREPOINT_NAME$$$"       # FIXME<br />$wl = spawnWebListener "OWA WebListener"              "$$$ISA_EXTERNAL_NLB_OWA_IP$$$"             "$$$ISA_EXTERNAL_NLB_OWA_NAME$$$"              $false $false $false<br />$wl.Properties.AuthenticationSchemes.Add("FBA with AD", 0)<br />$wl.Properties.DomainForAuthentication = "$$$__DOMAIN$$$"<br />$wl.save()<br /><br />$wl = spawnWebListener "Outlook Anywhere WebListener" "$$$ISA_EXTERNAL_NLB_OUTLOOKANYWHERE_IP$$$" "$$$ISA_EXTERNAL_NLB_OUTLOOKANYWHERE_NAME$$$"  $false $true  $true<br />$wl = spawnWebListener "Entourage WebListener"        "$$$ISA_EXTERNAL_NLB_ENTOURAGE_IP$$$"       "$$$ISA_EXTERNAL_NLB_ENTOURAGE_NAME$$$"        $true  $false $false<br />$wl = spawnWebListener "Evolution WebListener"        "$$$ISA_EXTERNAL_NLB_EVOLUTION_IP$$$"       "$$$ISA_EXTERNAL_NLB_EVOLUTION_NAME$$$"        $true  $false $false<br />$wl = spawnWebListener "Autodiscover WebListener"     "$$$ISA_EXTERNAL_NLB_AUTODISCOVER_IP$$$"    "$$$ISA_EXTERNAL_NLB_AUTODISCOVER_NAME$$$"     # FIXME<br />$wl = spawnWebListener "Mailarchive WebListener"      "$$$ISA_EXTERNAL_NLB_MAILARCHIVE_IP$$$"     "$$$ISA_EXTERNAL_NLB_MAILARCHIVE_NAME$$$"      $false $false $false<br />$wl.Properties.AuthenticationSchemes.Add("FBA with AD", 0)<br />$wl.Properties.DomainForAuthentication = "$$$__DOMAIN$$$"<br />$wl.save()<br /><br /># $wl = spawnWebListener "FS AAI WebListener"           "$$$ISA_EXTERNAL_NLB_FSAAI_IP$$$"           "$$$ISA_EXTERNAL_NLB_FSAAI_NAME$$$"          # FIXME<br /><br /></pre><br /><br /><b>debug_access_rule_allow_all.ps1</b><br /><br /><pre><br /># find our little array, reference it from $arr<br />$root = new-object -comobject "FPC.Root" -strict<br />$arr = $root.Arrays | select-object -first 1<br /><br />$debug = $arr.ArrayPolicy.PolicyRules.AddAccessRule("[DEBUG] Allow all to Internal")<br /><br /># Allow<br />$debug.Action = 0<br /># all traffic<br />$debug.AccessProperties.ProtocolSelectionMethod = 0<br /># From Local Host<br />$debug.SourceSelectionIPs.Networks.Add("Local Host", 0)<br /># To Internal<br />$debug.AccessProperties.DestinationSelectionIPs.Networks.Add("Internal", 0)<br /># By All Users<br />$debug.AccessProperties.UserSets.Add("All Users", 0)<br /><br /># disable by default<br />$debug.Enabled = $false<br /><br />$debug.save()<br /><br /></pre><br /><br /><b>enable_ICMP_from_remote_monitoring.ps1</b><br /><br /><pre><br /># get the ENUM value<br />$fpcSystemPolicyConfigGroup_RemoteMgmt_ICMP = 8<br /><br /># find our little array, reference it from $arr<br />$root = new-object -comobject "FPC.Root" -strict<br />$arr = $root.Arrays | select-object -first 1<br /><br /><br /># if adding the computerset fails, that means its already added, but the policy could be disabled<br /># so enable it now and save it, then add the computerset<br />$icmp = $arr.SystemPolicy.CreateConfigurationGroupInstance($fpcSystemPolicyConfigGroup_RemoteMgmt_ICMP)<br />$icmp.Enabled = $true<br />$icmp.save()<br /><br />""<br />"The following command may fail with a flashy red error, but that's ok"<br />""<br /><br />$icmp = $arr.SystemPolicy.CreateConfigurationGroupInstance($fpcSystemPolicyConfigGroup_RemoteMgmt_ICMP)<br />$icmp.SourceSelectionIPs.ComputerSets.add("Remote Monitoring Computers",0)<br />$icmp.save()<br /><br /></pre><br /><br /><b>enable_NLB.ps1</b><br /><br /><pre><br />$fpcNLBOperationModeUnicast = 0<br /><br /># find our little array, reference it from $arr<br />$root = new-object -comobject "FPC.Root" -strict<br />$arr = $root.Arrays | select-object -first 1<br /><br /><br />$arr.NetworkConfiguration.NLBConfiguration.NLBIntegrationEnabled = $true<br /><br /># Get the external network<br />$ext = $arr.NetworkConfiguration.Networks | where-Object { $_.name -eq "External" }<br /><br /># NLB settings<br />$ext.NLBCluster.SetVIPAndMask("$$$ISA_EXTERNAL_NLB_ACTIVESYNC_IP$$$","$$$ISA_EXTERNAL_NLB_NETMASK$$$")<br /><br /># generate a list of unique IP address to add (but skip the master VIP added above)<br />$iplist = (("$$$ISA_EXTERNAL_NLB_ACTIVESYNC_IP$$$", <br />            "$$$ISA_EXTERNAL_NLB_SHAREPOINT_IP$$$",<br />            "$$$ISA_EXTERNAL_NLB_IMAPS_IP$$$",<br />            "$$$ISA_EXTERNAL_NLB_POPS_IP$$$",<br />            "$$$ISA_EXTERNAL_NLB_OWA_IP$$$",<br />            "$$$ISA_EXTERNAL_NLB_OUTLOOKANYWHERE_IP$$$",<br />            "$$$ISA_EXTERNAL_NLB_ENTOURAGE_IP$$$",<br />            "$$$ISA_EXTERNAL_NLB_EVOLUTION_IP$$$",<br />            "$$$ISA_EXTERNAL_NLB_AUTODISCOVER_IP$$$",<br />            # "$$$ISA_EXTERNAL_NLB_FSAAI_IP$$$", #FIXME<br />            "$$$ISA_EXTERNAL_NLB_MAILARCHIVE_IP$$$") | Sort-Object) | Get-Unique | where-object { $_ -ne "$$$ISA_EXTERNAL_NLB_ACTIVESYNC_IP$$$" }<br /><br />foreach ($ip in $iplist) {<br />    $ext.NLBCluster.AdditionalVIPs.Add($ip)<br />}<br /><br />$ext.NLBCluster.OperationMode = $fpcNLBOperationModeUnicast<br />$ext.NLBCluster.NLBEnabled = $true<br /><br />$ext.save()<br /></pre><br /><br /><b>enable_sqllogging.ps1</b><br /><br /><pre><br />$fpcProxyWebLog = 1<br />$fpcProxyFwLog = 2<br />$fpcSQLDirectConnection = 4<br /><br /># find our little array, reference it from $arr<br />$root = new-object -comobject "FPC.Root" -strict<br />$arr = $root.Arrays | select-object -first 1<br /><br /><br /><br />$log = $arr.Logging.item($fpcProxyFwLog)<br /><br />$log.SQLServerName = "$$$SQL_SERVER_NAME$$$"<br />$log.SQLServerPort = $$$SQL_SERVER_PORT$$$<br />$log.LogDBTableName = "$$$SQL_FIREWALLLOG_TABLE$$$"<br />$log.SQLForceEncryption = $false<br />$log.LogDBUserName = "$$$SQL_SERVER_USER$$$"<br />$log.LogType = $fpcSQLDirectConnection<br />$log.SQLDatabase = "$$$SQL_FIREWALLLOG_DB$$$"<br />$log.DropConnectionOnLogError = $false<br /><br />$log.save()<br /><br /><br />$log = $arr.Logging.item($fpcProxyWebLog)<br /><br />$log.SQLServerName = "$$$SQL_SERVER_NAME$$$"<br />$log.SQLServerPort = $$$SQL_SERVER_PORT$$$<br />$log.LogDBTableName = "$$$SQL_WEBPROXYLOG_TABLE$$$"<br />$log.SQLForceEncryption = $false<br />$log.LogDBUserName = "$$$SQL_SERVER_USER$$$"<br />$log.LogType = $fpcSQLDirectConnection<br />$log.SQLDatabase = "$$$SQL_WEBPROXYLOG_DB$$$"<br />$log.DropConnectionOnLogError = $false<br /><br />$log.save()<br /><br /># don't stop firewalling on Log Failure<br />$logfail =  $arr.Alerts | Where-Object {$_.name -eq "Log Failure"}<br />$stopfw = $logfail.Actions.SetStopServices("StopServices", 1)<br />$stopfw.Enabled = $false<br />$stopfw.save()<br /><br /><br /></pre><br /><br /><b>publish_all_https.ps1</b><br /><br /><pre><br />$fpcWebServerThruHTTP = 0<br />$fpcWebServerThruSSL = 1<br />$fpcWebServerThruBothHTTPAndSSL = 2<br />$fpcFTPServer = 3<br /><br />$fpcSSLDontRequireSecureChannel = 0<br />$fpcSSLRequireSecureChannel = 1<br />$fpcSSLRequire128BitSecureChannel = 2<br />$fpcSSLRequireBoth = 3<br /><br />$fpcDelegationNonePassThrough = 0<br />$fpcDelegationNoneBlock = 1<br />$fpcDelegationSecurID = 2<br />$fpcDelegationBasic = 3<br />$fpcDelegationNTLM = 4<br />$fpcDelegationSPNEGO = 5<br />$fpcDelegationKerberosConstrained = 6<br /><br /><br /><br /># find our little array, reference it from $arr<br />$root = new-object -comobject "FPC.Root" -strict<br />$arr = $root.Arrays | select-object -first 1<br /><br />function spawnWebPublishingRule([string]$name, <br />                                [string]$listener,<br />                                [string]$ip,<br />                                [string]$backend,<br />                                [int]$authtype=$fpcDelegationNonePassThrough) {<br /><br />    $https = $arr.ArrayPolicy.PolicyRules.AddWebPublishingRule("$name")<br />    $res = $https.WebPublishingProperties.SetWebListener("$listener")<br />    $https.WebPublishingProperties.WebSite = "$backend"<br />    $https.WebPublishingProperties.PublishedServer = "$ip"<br />    $https.WebPublishingProperties.PublishedServerType = $fpcWebServerThruSSL<br />    $https.WebPublishingProperties.SSLRequireSecureChannel = $fpcSSLRequireBoth<br />    $res = $https.WebPublishingProperties.PublicNames.Add("$backend")<br />    $https.WebPublishingProperties.CredentialsDelegationType = $authtype<br /><br />    # remove default path mapping and add a new one, "same as internal"<br />    $res = $https.WebPublishingProperties.PathMappings.Remove(1)<br />    $res = $https.WebPublishingProperties.PathMappings.add("/*", $true, "/*")<br /><br />    $https.WebPublishingProperties.SendOriginalHostHeader = $true<br /><br />    <br />    if($authtype -eq $fpcDelegationKerberosConstrained) {<br />        $https.WebPublishingProperties.ServicePrincipalName = "$$$SPN_CAS$$$"<br />    }<br />    $https.save()<br /><br />    return $https<br />}<br /><br /><br />###########################<br />###<br />### OWA<br />###<br />###########################<br />$wpr = spawnWebPublishingRule "Publish OWA" "OWA WebListener" "$$$ISA_INTERNAL_NLB_OWA_IP$$$" "$$$ISA_INTERNAL_NLB_OWA_NAME$$$" $fpcDelegationKerberosConstrained<br />$wpr.WebPublishingProperties.PathMappings.Remove(1)<br />foreach ($path in @("/UnifiedMessaging/*", "/public/*", "/OWA/*", "/OAB/*", "/Exchweb/*", "/Exchange/*", "/EWS/*")) {<br />    $wpr.WebPublishingProperties.PathMappings.add("$path", $true, "$path")<br />}<br />$wpr.save()<br /><br />###########################<br />###<br />### Redirect / to /OWA/ for OWA<br />###<br />###########################<br />$wpr = spawnWebPublishingRule "Redirect OWA" "OWA WebListener" "$$$ISA_INTERNAL_NLB_OWA_IP$$$" "$$$ISA_INTERNAL_NLB_OWA_NAME$$$" $fpcDelegationNonePassThrough<br />$wpr.Action = 1 # Deny rule<br />$wpr.WebPublishingProperties.RedirectUrl = "https://$$$ISA_EXTERNAL_NLB_OWA_NAME$$$/OWA/"<br />$wpr.WebPublishingProperties.PathMappings.Remove(1)<br />foreach ($path in @("/")) {<br />    $wpr.WebPublishingProperties.PathMappings.add("$path", $true, "$path")<br />}<br />$wpr.save()<br /><br />###########################<br />###<br />### Entourage<br />###<br />###########################<br />$wpr = spawnWebPublishingRule "Publish Entourage" "Entourage WebListener" "$$$ISA_INTERNAL_NLB_ENTOURAGE_IP$$$" "$$$ISA_INTERNAL_NLB_ENTOURAGE_NAME$$$" $fpcDelegationKerberosConstrained <br />$wpr.WebPublishingProperties.PathMappings.Remove(1)<br />foreach ($path in @("/UnifiedMessaging/*", "/public/*", "/OWA/*", "/OAB/*", "/Exchweb/*", "/Exchange/*", "/EWS/*")) {<br />    $wpr.WebPublishingProperties.PathMappings.add("$path", $true, "$path")<br />}<br />$wpr.save()<br /><br />###########################<br />###<br />### Evolution<br />###<br />###########################<br />$wpr = spawnWebPublishingRule "Publish Evolution" "Evolution WebListener" "$$$ISA_INTERNAL_NLB_EVOLUTION_IP$$$" "$$$ISA_INTERNAL_NLB_EVOLUTION_NAME$$$" $fpcDelegationKerberosConstrained <br />$wpr.WebPublishingProperties.PathMappings.Remove(1)<br />foreach ($path in @("/UnifiedMessaging/*", "/public/*", "/OWA/*", "/OAB/*", "/Exchweb/*", "/Exchange/*", "/EWS/*")) {<br />    $wpr.WebPublishingProperties.PathMappings.add("$path", $true, "$path")<br />}<br />$wpr.save()<br /><br />###########################<br />###<br />### Outlook Anywhere<br />###<br />###########################<br />$wpr = spawnWebPublishingRule "Publish Outlook Anywhere" "Outlook Anywhere WebListener" "$$$ISA_INTERNAL_NLB_OUTLOOKANYWHERE_IP$$$" "$$$ISA_INTERNAL_NLB_OUTLOOKANYWHERE_NAME$$$" $fpcDelegationKerberosConstrained <br />$wpr.WebPublishingProperties.PathMappings.Remove(1)<br />foreach ($path in @("/UnifiedMessaging/*", "/rpc/*", "/OAB/*", "/EWS/*")) {<br />    $wpr.WebPublishingProperties.PathMappings.add("$path", $true, "$path")<br />}<br />$wpr.save()<br /><br />###########################<br />###<br />### Mailarchive<br />###<br />###########################<br />$wpr = spawnWebPublishingRule "Publish Mailarchive" "Mailarchive WebListener" "$$$ISA_INTERNAL_NLB_MAILARCHIVE_IP$$$" "$$$ISA_INTERNAL_NLB_MAILARCHIVE_NAME$$$" $fpcDelegationKerberosConstrained<br />$wpr.WebPublishingProperties.PathMappings.Remove(1)<br />foreach ($path in @("/EnterpriseVault/*")) {<br />    $wpr.WebPublishingProperties.PathMappings.add("$path", $true, "$path")<br />}<br />$wpr.WebPublishingProperties.ServicePrincipalName = "$$$SPN_EVAULT1$$$"<br />$wpr.save()<br /><br />###########################<br />###<br />### Redirect / to /EnterpriseVault/ for Mailarchive<br />###<br />###########################<br />$wpr = spawnWebPublishingRule "Redirect Mailarchive" "Mailarchive WebListener" "$$$ISA_INTERNAL_NLB_MAILARCHIVE_IP$$$" "$$$ISA_INTERNAL_NLB_MAILARCHIVE_NAME$$$" $fpcDelegationNonePassThrough<br />$wpr.Action = 1 # Deny rule<br />$wpr.WebPublishingProperties.RedirectUrl = "https://$$$ISA_EXTERNAL_NLB_MAILARCHIVE_NAME$$$/EnterpriseVault/"<br />$wpr.WebPublishingProperties.PathMappings.Remove(1)<br />foreach ($path in @("/")) {<br />    $wpr.WebPublishingProperties.PathMappings.add("$path", $true, "$path")<br />}<br />$wpr.save()<br /><br />###########################<br />###<br />### Cold Mailarchive<br />###<br />###########################<br />$wpr = spawnWebPublishingRule "Publish Cold Mailarchive" "Mailarchive WebListener" "$$$ISA_INTERNAL_NLB_COLDMAILARCHIVE_IP$$$" "$$$ISA_INTERNAL_NLB_COLDMAILARCHIVE_NAME$$$" $fpcDelegationKerberosConstrained<br />$wpr.WebPublishingProperties.PathMappings.Remove(1)<br />foreach ($path in @("/EnterpriseVault/*")) {<br />    $wpr.WebPublishingProperties.PathMappings.add("$path", $true, "$path")<br />}<br />$wpr.WebPublishingProperties.ServicePrincipalName = "$$$SPN_EVAULT2$$$"<br />$wpr.Enabled = $false<br />$wpr.save()<br /><br />###########################<br />###<br />### ActiveSync<br />###<br />###########################<br />$wpr = spawnWebPublishingRule "Publish ActiveSync" "ActiveSync WebListener" "$$$ISA_INTERNAL_NLB_ACTIVESYNC_IP$$$" "$$$ISA_INTERNAL_NLB_ACTIVESYNC_NAME$$$" $fpcDelegationKerberosConstrained <br />$wpr.WebPublishingProperties.PathMappings.Remove(1)<br />foreach ($path in @("/Microsoft-Server-ActiveSync/*")) {<br />    $wpr.WebPublishingProperties.PathMappings.add("$path", $true, "$path")<br />}<br />$wpr.save()<br /><br />###########################<br />###<br />### AutoDiscover<br />###<br />###########################<br />$wpr = spawnWebPublishingRule "Publish Autodiscover" "Autodiscover WebListener" "$$$ISA_INTERNAL_NLB_AUTODISCOVER_IP$$$" "$$$ISA_INTERNAL_NLB_AUTODISCOVER_NAME$$$" $fpcDelegationKerberosConstrained<br />$wpr.WebPublishingProperties.TranslateLinks = $false<br />$wpr.WebPublishingProperties.PathMappings.Remove(1)<br />foreach ($path in @("/Autodiscover/*")) {<br />    $wpr.WebPublishingProperties.PathMappings.add("$path", $true, "$path")<br />}<br />$wpr.save()<br /><br /><br />###########################<br />###<br />### move "Redirect OWA" rule to the top<br />###<br />###########################<br />$denyrule = $arr.ArrayPolicy.PolicyRules | where-object { $_.name -eq "Redirect OWA"}<br />$denyruleorder = $denyrule.Order<br /><br />for ($i=$denyruleorder; $i -gt 1; $i--) {<br />    $arr.ArrayPolicy.PolicyRules.MoveUp($i)<br />}<br />$arr.save()<br /><br />###########################<br />###<br />### move "Redirect Mailarchive" rule to the top<br />###<br />###########################<br />$denyrule = $arr.ArrayPolicy.PolicyRules | where-object { $_.name -eq "Redirect Mailarchive"}<br />$denyruleorder = $denyrule.Order<br /><br />for ($i=$denyruleorder; $i -gt 1; $i--) {<br />    $arr.ArrayPolicy.PolicyRules.MoveUp($i)<br />}<br />$arr.save()<br /><br /></pre><br /><br /><b>publish_imaps_pops.ps1</b><br /><br /><pre><br />$fpcAllIPAddresses = 0<br />$fpcSpecifiedIPAddress = 2<br /><br /><br /># find our little array, reference it from $arr<br />$root = new-object -comobject "FPC.Root" -strict<br />$arr = $root.Arrays | select-object -first 1<br /><br /><br /># A new server publishing rule<br />$imaps = $arr.ArrayPolicy.PolicyRules.AddServerPublishingRule("Publish IMAPs","$$$ISA_INTERNAL_NLB_IMAPS_IP$$$", "IMAPS Server")<br /><br /># listen on the external side<br />$imaps.ServerPublishingProperties.IPsOnNetworks.Add("External", $fpcSpecifiedIPAddress, "$$$ISA_EXTERNAL_NLB_IMAPS_IP$$$")<br /><br /># and make connections appear to come from the ISA server<br />$imaps.ServerPublishingProperties.UseFirewallIPAsSource = $true<br />$imaps.save()<br /><br />$pops = $arr.ArrayPolicy.PolicyRules.AddServerPublishingRule("Publish POPs", "$$$ISA_INTERNAL_NLB_POPS_IP$$$", "POP3S Server")<br />$pops.ServerPublishingProperties.IPsOnNetworks.Add("External", $fpcSpecifiedIPAddress, "$$$ISA_EXTERNAL_NLB_POPS_IP$$$")<br />$pops.ServerPublishingProperties.UseFirewallIPAsSource = $true<br />$pops.save()<br /><br /></pre><br /><br /><b>select_network_template_and_default_policy.ps1</b><br /><br /><pre><br /># find our little array, reference it from $arr<br />$root = new-object -comobject "FPC.Root" -strict<br />$arr = $root.Arrays | select-object -first 1<br /><br /># template: Edge firewall<br /># default policy: block all<br /><br />$arr.SelectNetworkTemplateAndPolicy("Edge Firewall", "Block all")<br /></pre><br /><br /><br /><br /><br />StevensBlogSpotFilterThing --><br /><a href="//2008/04/01/configuring-isa-through-powershell-some/">Some time ago</a> I posted a few examples of Powershell scripts to configure ISA. Now that I look back at it, I saw it was posted on April 1st. Rest assured, those examples are no joke :)<br /><br />It's now about 3 weeks later and time for another update.<br /><br />Before I paste the scripts, some explanation is needed. <br /><br />First of all, all my scripts are processed by a template engine before they are executed. We currently have 3 domains (2 experimental and 1 production) where 2 ISA servers and CSS server need to be setup.<br />I want the setup to be identical, except for things like SSL certificates, IP addresses and usernames and such. All of those variables are placed in the scripts (and INIfiles not shown here) by the template engine. Such variables can be recognized by the "$$$" in front and to the back of them. For example: $$$__DOMAIN$$$ will be replaced with the name of the domain that is currently being installed in.<br /><br />Next, What do these scripts do ?<br /><br /><dl><br /><dt>access_rule_for_scom.ps1</dt><br /><dd>Creates an access rule for the SCOM (MOM) monitoring server. This will allow connections from the ISA server to the SCOM server on some port.</dd><br /><dt>access_rule_for_sqllogging.ps1</dt><br /><dd></dd><br /><dt>add_nagios_to_remote_monitoring.ps1</dt><br /><dd>Adds our Nagios server to the "Remote Monitoring Computers" computerset defined in some other script.</dd><br /><dt>allow_mgmt_from_css.ps1</dt><br /><dd>Adds the CSS server to the Remote Management Computers computerset, because otherwise, it won't be able to keep a look on the ISA servers (when having the CSS on a different physical machine than the ISA servers)</dd><br /><dt>allow_mgmt_from_subnet.ps1</dt><br /><dd>Adds a specific subnet to the Remote Management Computers computerset, as to not lock us out when we install from a different location than the usual one</dd><br /><dt>allow_RDP_from_kulnetnat.ps1</dt><br /><dd>This one adds our NAT to the "Enterprise Remote Management Computers" computerset</dd><br /><dt>configure_intra_array_addresses.ps1</dt><br /><dd>Configures the intra-array IP addresses used by the ISA servers. We use a separate network for this, with their own IP addresses. Beware !! Both ISA servers need to be installed and joined in the ISA array before you can configure these IP addresses. Why ? Well because joining the ISA server in the array will create some entries in the CSS that can't be created otherwise (I think)</dd><br /><dt>create_new_array.ps1</dt><br /><dd>Create a fresh array. At first, I used the "InstallNewArrayAndServer.ini" configfile provided with the ISA installation files, for unattended installation. But after a while I was sick of waiting untill an ISA was installed to configure the CSS. This script takes care of that. It will create an array in the CSS and you can start configuring it, even before any ISA servers are joined.</dd><br /><dt>create_weblisteners.ps1</dt><br /><dd>Here, I've experimented with a powershell function. The function creates a weblistener the way we want it and it is then called for every weblistenenr we want to add. We use a separate IP per certificate, and 1 IP per weblistener. Authentication method differs depending to the weblistener.</dd><br /><dt>debug_access_rule_allow_all.ps1</dt><br /><dd>Creates a debug accessrule allowing all traffic from the ISA to the Internal network. It is disabled by default.</dd><br /><dt>enable_ICMP_from_remote_monitoring.ps1</dt><br /><dd>Adds the "Remote Monitoring Computers" computerset to the ICMP system policy rule. System policy rules are configured differently from other policy rules, so it was sortof interesting to get this working.</dd><br /><dt>enable_NLB.ps1</dt><br /><dd>Enable Network Load Balancing on the External network and add all the IPs we will use in the weblisteners. We're also using unicast NLB because we're too lazy to configure our network infrastructure for multicast NLB.</dd><br /><dt>enable_sqllogging.ps1</dt><br /><dd>Configures the Logging settings to log to an external SQL server. We also don't want ISA to stop working when SQL fails, so this script disables that.</dd><br /><dt>publish_all_https.ps1</dt><br /><dd>This script created all webpublishing rules, using the weblisteners created in an earlier script. Again, a function is used to keep the code short. This script also shows how to reorder rules.</dd><br /><dt>publish_imaps_pops.ps1</dt><br /><dd>Publish IMAPs and POPs</dd><br /><dt>select_network_template_and_default_policy.ps1</dt><br /><dd>Select the "Edge Firewall" network template and set the default policy to "block all"</dd><br /></dl><br /><br />Here they are, copied directly from my screen:<br /><br /><b>access_rule_for_scom.ps1</b><br /><br /><pre><br /># find our little array, reference it from $arr<br />$root = new-object -comobject "FPC.Root" -strict<br />$arr = $root.Arrays | select-object -first 1<br /><br /># we want to allow connections to SCOM from the ISA server<br /># First, lets define a group "Remote Monitoring Computers" that will hold all SCOM computers<br />$newset = $arr.RuleElements.ComputerSets.Add("Remote Monitoring Computers")<br /><br /># Now we add an IP address in it, and name it "SCOM"<br /># We only have 1 SCOM computer at the moment.<br />$newset.Computers.Add("SCOM","$$$SCOM_IP_ADDRESS$$$")<br /><br /># save this new computer set<br />$arr.save()<br /><br /># create a new protocol definition<br />$proto = $arr.RuleElements.ProtocolDefinitions.Add("System Center Operations Manager 2007 agent")<br /># outbound to port 5723<br />$proto.PrimaryConnections.AddTCP(1, 5723, 5723)<br />$proto.save()<br /><br />$scomrule = $arr.ArrayPolicy.PolicyRules.AddAccessRule("Outbound to SCOM")<br /><br /># Allow<br />$scomrule.Action = 0<br /># only the following selected protocols ...<br />$scomrule.AccessProperties.ProtocolSelectionMethod = 1<br /># ... The SCOM 2007 protocol<br />$scomrule.AccessProperties.SpecifiedProtocols.Add("System Center Operations Manager 2007 agent", 0)<br /># From Local Host<br />$scomrule.SourceSelectionIPs.Networks.Add("Local Host", 0)<br /># To Remote Monitoring Computers<br />$scomrule.AccessProperties.DestinationSelectionIPs.ComputerSets.Add("Remote Monitoring Computers", 0)<br /># By All Users<br />$scomrule.AccessProperties.UserSets.Add("All Users", 0)<br /><br />$scomrule.save()<br /></pre><br /><br /><b>access_rule_for_sqllogging.ps1</b><br /><br /><pre><br /># find our little array, reference it from $arr<br />$root = new-object -comobject "FPC.Root" -strict<br />$arr = $root.Arrays | select-object -first 1<br /><br /><br /># First, create a new protocol definition<br />$proto = $arr.RuleElements.ProtocolDefinitions.Add("SQL Cluster")<br /># outbound to SQL server port<br />$proto.PrimaryConnections.AddTCP(1, $$$SQL_SERVER_PORT$$$, $$$SQL_SERVER_PORT$$$)<br />$proto.save()<br /><br /># Next, create a computerset for the SQL cluster<br />$newset = $arr.RuleElements.ComputerSets.Add("SQL Server Cluster")<br />$newset.Computers.Add("SQL Server for ISA","$$$SQL_SERVER_IP_ADDRESS$$$")<br />$newset.save()<br /><br /><br />$sqlrule = $arr.ArrayPolicy.PolicyRules.AddAccessRule("Outbound to SQL Cluster")<br /><br /># Allow<br />$sqlrule.Action = 0<br /># only the following selected protocols ...<br />$sqlrule.AccessProperties.ProtocolSelectionMethod = 1<br /># ... The SQL Cluster protocol<br />$sqlrule.AccessProperties.SpecifiedProtocols.Add("SQL Cluster", 0)<br /># From Local Host<br />$sqlrule.SourceSelectionIPs.Networks.Add("Local Host", 0)<br /># To SQL Cluster<br />$sqlrule.AccessProperties.DestinationSelectionIPs.ComputerSets.Add("SQL Server Cluster", 0)<br /># By All Users<br />$sqlrule.AccessProperties.UserSets.Add("All Users", 0)<br /><br />$sqlrule.save()<br /></pre><br /><br /><b>add_nagios_to_remote_monitoring.ps1</b><br /><br /><pre><br /># find our little array, reference it from $arr<br />$root = new-object -comobject "FPC.Root" -strict<br />$arr = $root.Arrays | select-object -first 1<br /><br />$set = $arr.RuleElements.ComputerSets | where-object {$_.name -eq "Remote Monitoring Computers"}<br />$set.Computers.Add("KulNet Nagios","$$$NAGIOS_IP_ADDRESS$$$")<br />$set.save()<br /></pre><br /><br /><b>allow_mgmt_from_css.ps1</b><br /><br /><pre><br /># find our little array, reference it from $arr<br />$root = new-object -comobject "FPC.Root" -strict<br />$arr = $root.Arrays | select-object -first 1<br /><br /><br />$mgmt = $arr.RuleElements.ComputerSets | where-object { $_.name -eq "Remote Management Computers" }<br />$mgmt.Computers.Add("CSS1","$$$STORAGESERVER_IP$$$")<br />$arr.save()<br /></pre><br /><br /><b>allow_mgmt_from_subnet.ps1</b><br /><br /><pre><br /># find our little array, reference it from $arr<br />$root = new-object -comobject "FPC.Root" -strict<br />$arr = $root.Arrays | select-object -first 1<br /><br /><br />$mgmt = $arr.RuleElements.ComputerSets | where-object { $_.name -eq "Remote Management Computers" }<br />$mgmt.Subnets.Add("Management Subnet","$$$MANAGEMENT_SUBNET$$$", "$$$MANAGEMENT_SUBNET_MASK$$$")<br />$arr.save()<br /></pre><br /><br /><b>allow_RDP_from_kulnetnat.ps1</b><br /><br /><pre><br /># find our little array, reference it from $arr<br />$root = new-object -comobject "FPC.Root" -strict<br /><br />$remotemgmt = $root.Enterprise.RuleElements.ComputerSets | where-object { $_.name -eq "Enterprise Remote Management Computers" }<br /><br />$remotemgmt.Computers.add("$$$KULNET_NAT_NAME$$$", "$$$KULNET_NAT_IP$$$")<br />$remotemgmt.Computers.save()<br /></pre><br /><br /><b>configure_intra_array_addresses.ps1</b><br /><br /><pre><br /># find our little array, reference it from $arr<br />$root = new-object -comobject "FPC.Root" -strict<br />$arr = $root.Arrays | select-object -first 1<br /><br /># let NLB communication go over the specialised network<br />$isa1 = $arr.Servers | Where-Object { $_.name -eq "$$$__HOST_ISA1_NAME$$$" }<br />$isa1.IntraArrayAddress = "$$$__HOST_ISA1_HB$$$"<br />$isa1.save()<br /><br />$isa2 = $arr.Servers | Where-Object { $_.name -eq "$$$__HOST_ISA2_NAME$$$" }<br />$isa2.IntraArrayAddress = "$$$__HOST_ISA2_HB$$$"<br />$isa2.save()<br /><br /></pre><br /><br /><b>create_new_array.ps1</b><br /><br /><pre><br />$root = new-object -comobject "FPC.Root" -strict<br /><br />$arr = $root.Arrays.add("$$$ARRAY_NAME$$$")<br />$internal = $arr.NetworkConfiguration.Networks | Where-Object {$_.name -eq "Internal"}<br />$internal.IpRangeSet.Add("$$$ARRAY_INTERNALNET_START$$$","$$$ARRAY_INTERNALNET_END$$$")<br /><br />$root.save()<br /></pre><br /><br /><b>create_weblisteners.ps1</b><br /><br /><pre><br />$fpcSpecifiedIPAddress = 2<br /><br />$fpcRedirectHTTPAsHTTPSDisabled = 0<br />$fpcRedirectHTTPAsHTTPSIfAuthenticated = 1<br />$fpcRedirectHTTPAsHTTPSAlways = 2<br /><br />function spawnWebListener([string]$name, <br />                          [string]$ip, <br />                          [string]$cn, <br />                          [boolean]$basicauth=$true, <br />                          [boolean]$digest=$false, <br />                          [boolean]$integrated=$false) {<br />    $hash = (dir cert:\localmachine\my | where-object { $_.subject -like "CN=$cn*" }).getCertHash()<br />    <br />    $nwl = $arr.RuleElements.WebListeners.add($name)<br /><br />    $res = $nwl.IPsOnNetworks.Add("External", $fpcSpecifiedIPAddress, $ip)<br />    $nwl.Properties.TCPPort = 80<br />    $nwl.Properties.RedirectHTTPAsHTTPS = $fpcRedirectHTTPAsHTTPSAlways<br />    $nwl.Properties.SSLPort = 443<br />    $res = $nwl.Properties.AppliedSSLCertificates.Add([byte[]]($hash))<br />    $nwl.Properties.BasicAuthentication = $basicauth<br />    $nwl.Properties.DigestAuthentication = $digest<br />    $nwl.Properties.IntegratedWindowsAuthentication = $integrated<br />    $nwl.Properties.AlwaysAuthenticate = $true<br />    $nwl.save()<br /><br />    return $nwl<br />}<br /><br /><br /># find our little array, reference it from $arr<br />$root = new-object -comobject "FPC.Root" -strict<br />$arr = $root.Arrays | select-object -first 1<br /><br /><br />$wl = spawnWebListener "ActiveSync WebListener"       "$$$ISA_EXTERNAL_NLB_ACTIVESYNC_IP$$$"      "$$$ISA_EXTERNAL_NLB_ACTIVESYNC_NAME$$$"       $false $true  $true<br />$wl = spawnWebListener "Sharepoint WebListener"       "$$$ISA_EXTERNAL_NLB_SHAREPOINT_IP$$$"      "$$$ISA_EXTERNAL_NLB_SHAREPOINT_NAME$$$"       # FIXME<br />$wl = spawnWebListener "OWA WebListener"              "$$$ISA_EXTERNAL_NLB_OWA_IP$$$"             "$$$ISA_EXTERNAL_NLB_OWA_NAME$$$"              $false $false $false<br />$wl.Properties.AuthenticationSchemes.Add("FBA with AD", 0)<br />$wl.Properties.DomainForAuthentication = "$$$__DOMAIN$$$"<br />$wl.save()<br /><br />$wl = spawnWebListener "Outlook Anywhere WebListener" "$$$ISA_EXTERNAL_NLB_OUTLOOKANYWHERE_IP$$$" "$$$ISA_EXTERNAL_NLB_OUTLOOKANYWHERE_NAME$$$"  $false $true  $true<br />$wl = spawnWebListener "Entourage WebListener"        "$$$ISA_EXTERNAL_NLB_ENTOURAGE_IP$$$"       "$$$ISA_EXTERNAL_NLB_ENTOURAGE_NAME$$$"        $true  $false $false<br />$wl = spawnWebListener "Evolution WebListener"        "$$$ISA_EXTERNAL_NLB_EVOLUTION_IP$$$"       "$$$ISA_EXTERNAL_NLB_EVOLUTION_NAME$$$"        $true  $false $false<br />$wl = spawnWebListener "Autodiscover WebListener"     "$$$ISA_EXTERNAL_NLB_AUTODISCOVER_IP$$$"    "$$$ISA_EXTERNAL_NLB_AUTODISCOVER_NAME$$$"     # FIXME<br />$wl = spawnWebListener "Mailarchive WebListener"      "$$$ISA_EXTERNAL_NLB_MAILARCHIVE_IP$$$"     "$$$ISA_EXTERNAL_NLB_MAILARCHIVE_NAME$$$"      $false $false $false<br />$wl.Properties.AuthenticationSchemes.Add("FBA with AD", 0)<br />$wl.Properties.DomainForAuthentication = "$$$__DOMAIN$$$"<br />$wl.save()<br /><br /># $wl = spawnWebListener "FS AAI WebListener"           "$$$ISA_EXTERNAL_NLB_FSAAI_IP$$$"           "$$$ISA_EXTERNAL_NLB_FSAAI_NAME$$$"          # FIXME<br /><br /></pre><br /><br /><b>debug_access_rule_allow_all.ps1</b><br /><br /><pre><br /># find our little array, reference it from $arr<br />$root = new-object -comobject "FPC.Root" -strict<br />$arr = $root.Arrays | select-object -first 1<br /><br />$debug = $arr.ArrayPolicy.PolicyRules.AddAccessRule("[DEBUG] Allow all to Internal")<br /><br /># Allow<br />$debug.Action = 0<br /># all traffic<br />$debug.AccessProperties.ProtocolSelectionMethod = 0<br /># From Local Host<br />$debug.SourceSelectionIPs.Networks.Add("Local Host", 0)<br /># To Internal<br />$debug.AccessProperties.DestinationSelectionIPs.Networks.Add("Internal", 0)<br /># By All Users<br />$debug.AccessProperties.UserSets.Add("All Users", 0)<br /><br /># disable by default<br />$debug.Enabled = $false<br /><br />$debug.save()<br /><br /></pre><br /><br /><b>enable_ICMP_from_remote_monitoring.ps1</b><br /><br /><pre><br /># get the ENUM value<br />$fpcSystemPolicyConfigGroup_RemoteMgmt_ICMP = 8<br /><br /># find our little array, reference it from $arr<br />$root = new-object -comobject "FPC.Root" -strict<br />$arr = $root.Arrays | select-object -first 1<br /><br /><br /># if adding the computerset fails, that means its already added, but the policy could be disabled<br /># so enable it now and save it, then add the computerset<br />$icmp = $arr.SystemPolicy.CreateConfigurationGroupInstance($fpcSystemPolicyConfigGroup_RemoteMgmt_ICMP)<br />$icmp.Enabled = $true<br />$icmp.save()<br /><br />""<br />"The following command may fail with a flashy red error, but that's ok"<br />""<br /><br />$icmp = $arr.SystemPolicy.CreateConfigurationGroupInstance($fpcSystemPolicyConfigGroup_RemoteMgmt_ICMP)<br />$icmp.SourceSelectionIPs.ComputerSets.add("Remote Monitoring Computers",0)<br />$icmp.save()<br /><br /></pre><br /><br /><b>enable_NLB.ps1</b><br /><br /><pre><br />$fpcNLBOperationModeUnicast = 0<br /><br /># find our little array, reference it from $arr<br />$root = new-object -comobject "FPC.Root" -strict<br />$arr = $root.Arrays | select-object -first 1<br /><br /><br />$arr.NetworkConfiguration.NLBConfiguration.NLBIntegrationEnabled = $true<br /><br /># Get the external network<br />$ext = $arr.NetworkConfiguration.Networks | where-Object { $_.name -eq "External" }<br /><br /># NLB settings<br />$ext.NLBCluster.SetVIPAndMask("$$$ISA_EXTERNAL_NLB_ACTIVESYNC_IP$$$","$$$ISA_EXTERNAL_NLB_NETMASK$$$")<br /><br /># generate a list of unique IP address to add (but skip the master VIP added above)<br />$iplist = (("$$$ISA_EXTERNAL_NLB_ACTIVESYNC_IP$$$", <br />            "$$$ISA_EXTERNAL_NLB_SHAREPOINT_IP$$$",<br />            "$$$ISA_EXTERNAL_NLB_IMAPS_IP$$$",<br />            "$$$ISA_EXTERNAL_NLB_POPS_IP$$$",<br />            "$$$ISA_EXTERNAL_NLB_OWA_IP$$$",<br />            "$$$ISA_EXTERNAL_NLB_OUTLOOKANYWHERE_IP$$$",<br />            "$$$ISA_EXTERNAL_NLB_ENTOURAGE_IP$$$",<br />            "$$$ISA_EXTERNAL_NLB_EVOLUTION_IP$$$",<br />            "$$$ISA_EXTERNAL_NLB_AUTODISCOVER_IP$$$",<br />            # "$$$ISA_EXTERNAL_NLB_FSAAI_IP$$$", #FIXME<br />            "$$$ISA_EXTERNAL_NLB_MAILARCHIVE_IP$$$") | Sort-Object) | Get-Unique | where-object { $_ -ne "$$$ISA_EXTERNAL_NLB_ACTIVESYNC_IP$$$" }<br /><br />foreach ($ip in $iplist) {<br />    $ext.NLBCluster.AdditionalVIPs.Add($ip)<br />}<br /><br />$ext.NLBCluster.OperationMode = $fpcNLBOperationModeUnicast<br />$ext.NLBCluster.NLBEnabled = $true<br /><br />$ext.save()<br /></pre><br /><br /><b>enable_sqllogging.ps1</b><br /><br /><pre><br />$fpcProxyWebLog = 1<br />$fpcProxyFwLog = 2<br />$fpcSQLDirectConnection = 4<br /><br /># find our little array, reference it from $arr<br />$root = new-object -comobject "FPC.Root" -strict<br />$arr = $root.Arrays | select-object -first 1<br /><br /><br /><br />$log = $arr.Logging.item($fpcProxyFwLog)<br /><br />$log.SQLServerName = "$$$SQL_SERVER_NAME$$$"<br />$log.SQLServerPort = $$$SQL_SERVER_PORT$$$<br />$log.LogDBTableName = "$$$SQL_FIREWALLLOG_TABLE$$$"<br />$log.SQLForceEncryption = $false<br />$log.LogDBUserName = "$$$SQL_SERVER_USER$$$"<br />$log.LogType = $fpcSQLDirectConnection<br />$log.SQLDatabase = "$$$SQL_FIREWALLLOG_DB$$$"<br />$log.DropConnectionOnLogError = $false<br /><br />$log.save()<br /><br /><br />$log = $arr.Logging.item($fpcProxyWebLog)<br /><br />$log.SQLServerName = "$$$SQL_SERVER_NAME$$$"<br />$log.SQLServerPort = $$$SQL_SERVER_PORT$$$<br />$log.LogDBTableName = "$$$SQL_WEBPROXYLOG_TABLE$$$"<br />$log.SQLForceEncryption = $false<br />$log.LogDBUserName = "$$$SQL_SERVER_USER$$$"<br />$log.LogType = $fpcSQLDirectConnection<br />$log.SQLDatabase = "$$$SQL_WEBPROXYLOG_DB$$$"<br />$log.DropConnectionOnLogError = $false<br /><br />$log.save()<br /><br /># don't stop firewalling on Log Failure<br />$logfail =  $arr.Alerts | Where-Object {$_.name -eq "Log Failure"}<br />$stopfw = $logfail.Actions.SetStopServices("StopServices", 1)<br />$stopfw.Enabled = $false<br />$stopfw.save()<br /><br /><br /></pre><br /><br /><b>publish_all_https.ps1</b><br /><br /><pre><br />$fpcWebServerThruHTTP = 0<br />$fpcWebServerThruSSL = 1<br />$fpcWebServerThruBothHTTPAndSSL = 2<br />$fpcFTPServer = 3<br /><br />$fpcSSLDontRequireSecureChannel = 0<br />$fpcSSLRequireSecureChannel = 1<br />$fpcSSLRequire128BitSecureChannel = 2<br />$fpcSSLRequireBoth = 3<br /><br />$fpcDelegationNonePassThrough = 0<br />$fpcDelegationNoneBlock = 1<br />$fpcDelegationSecurID = 2<br />$fpcDelegationBasic = 3<br />$fpcDelegationNTLM = 4<br />$fpcDelegationSPNEGO = 5<br />$fpcDelegationKerberosConstrained = 6<br /><br /><br /><br /># find our little array, reference it from $arr<br />$root = new-object -comobject "FPC.Root" -strict<br />$arr = $root.Arrays | select-object -first 1<br /><br />function spawnWebPublishingRule([string]$name, <br />                                [string]$listener,<br />                                [string]$ip,<br />                                [string]$backend,<br />                                [int]$authtype=$fpcDelegationNonePassThrough) {<br /><br />    $https = $arr.ArrayPolicy.PolicyRules.AddWebPublishingRule("$name")<br />    $res = $https.WebPublishingProperties.SetWebListener("$listener")<br />    $https.WebPublishingProperties.WebSite = "$backend"<br />    $https.WebPublishingProperties.PublishedServer = "$ip"<br />    $https.WebPublishingProperties.PublishedServerType = $fpcWebServerThruSSL<br />    $https.WebPublishingProperties.SSLRequireSecureChannel = $fpcSSLRequireBoth<br />    $res = $https.WebPublishingProperties.PublicNames.Add("$backend")<br />    $https.WebPublishingProperties.CredentialsDelegationType = $authtype<br /><br />    # remove default path mapping and add a new one, "same as internal"<br />    $res = $https.WebPublishingProperties.PathMappings.Remove(1)<br />    $res = $https.WebPublishingProperties.PathMappings.add("/*", $true, "/*")<br /><br />    $https.WebPublishingProperties.SendOriginalHostHeader = $true<br /><br />    <br />    if($authtype -eq $fpcDelegationKerberosConstrained) {<br />        $https.WebPublishingProperties.ServicePrincipalName = "$$$SPN_CAS$$$"<br />    }<br />    $https.save()<br /><br />    return $https<br />}<br /><br /><br />###########################<br />###<br />### OWA<br />###<br />###########################<br />$wpr = spawnWebPublishingRule "Publish OWA" "OWA WebListener" "$$$ISA_INTERNAL_NLB_OWA_IP$$$" "$$$ISA_INTERNAL_NLB_OWA_NAME$$$" $fpcDelegationKerberosConstrained<br />$wpr.WebPublishingProperties.PathMappings.Remove(1)<br />foreach ($path in @("/UnifiedMessaging/*", "/public/*", "/OWA/*", "/OAB/*", "/Exchweb/*", "/Exchange/*", "/EWS/*")) {<br />    $wpr.WebPublishingProperties.PathMappings.add("$path", $true, "$path")<br />}<br />$wpr.save()<br /><br />###########################<br />###<br />### Redirect / to /OWA/ for OWA<br />###<br />###########################<br />$wpr = spawnWebPublishingRule "Redirect OWA" "OWA WebListener" "$$$ISA_INTERNAL_NLB_OWA_IP$$$" "$$$ISA_INTERNAL_NLB_OWA_NAME$$$" $fpcDelegationNonePassThrough<br />$wpr.Action = 1 # Deny rule<br />$wpr.WebPublishingProperties.RedirectUrl = "https://$$$ISA_EXTERNAL_NLB_OWA_NAME$$$/OWA/"<br />$wpr.WebPublishingProperties.PathMappings.Remove(1)<br />foreach ($path in @("/")) {<br />    $wpr.WebPublishingProperties.PathMappings.add("$path", $true, "$path")<br />}<br />$wpr.save()<br /><br />###########################<br />###<br />### Entourage<br />###<br />###########################<br />$wpr = spawnWebPublishingRule "Publish Entourage" "Entourage WebListener" "$$$ISA_INTERNAL_NLB_ENTOURAGE_IP$$$" "$$$ISA_INTERNAL_NLB_ENTOURAGE_NAME$$$" $fpcDelegationKerberosConstrained <br />$wpr.WebPublishingProperties.PathMappings.Remove(1)<br />foreach ($path in @("/UnifiedMessaging/*", "/public/*", "/OWA/*", "/OAB/*", "/Exchweb/*", "/Exchange/*", "/EWS/*")) {<br />    $wpr.WebPublishingProperties.PathMappings.add("$path", $true, "$path")<br />}<br />$wpr.save()<br /><br />###########################<br />###<br />### Evolution<br />###<br />###########################<br />$wpr = spawnWebPublishingRule "Publish Evolution" "Evolution WebListener" "$$$ISA_INTERNAL_NLB_EVOLUTION_IP$$$" "$$$ISA_INTERNAL_NLB_EVOLUTION_NAME$$$" $fpcDelegationKerberosConstrained <br />$wpr.WebPublishingProperties.PathMappings.Remove(1)<br />foreach ($path in @("/UnifiedMessaging/*", "/public/*", "/OWA/*", "/OAB/*", "/Exchweb/*", "/Exchange/*", "/EWS/*")) {<br />    $wpr.WebPublishingProperties.PathMappings.add("$path", $true, "$path")<br />}<br />$wpr.save()<br /><br />###########################<br />###<br />### Outlook Anywhere<br />###<br />###########################<br />$wpr = spawnWebPublishingRule "Publish Outlook Anywhere" "Outlook Anywhere WebListener" "$$$ISA_INTERNAL_NLB_OUTLOOKANYWHERE_IP$$$" "$$$ISA_INTERNAL_NLB_OUTLOOKANYWHERE_NAME$$$" $fpcDelegationKerberosConstrained <br />$wpr.WebPublishingProperties.PathMappings.Remove(1)<br />foreach ($path in @("/UnifiedMessaging/*", "/rpc/*", "/OAB/*", "/EWS/*")) {<br />    $wpr.WebPublishingProperties.PathMappings.add("$path", $true, "$path")<br />}<br />$wpr.save()<br /><br />###########################<br />###<br />### Mailarchive<br />###<br />###########################<br />$wpr = spawnWebPublishingRule "Publish Mailarchive" "Mailarchive WebListener" "$$$ISA_INTERNAL_NLB_MAILARCHIVE_IP$$$" "$$$ISA_INTERNAL_NLB_MAILARCHIVE_NAME$$$" $fpcDelegationKerberosConstrained<br />$wpr.WebPublishingProperties.PathMappings.Remove(1)<br />foreach ($path in @("/EnterpriseVault/*")) {<br />    $wpr.WebPublishingProperties.PathMappings.add("$path", $true, "$path")<br />}<br />$wpr.WebPublishingProperties.ServicePrincipalName = "$$$SPN_EVAULT1$$$"<br />$wpr.save()<br /><br />###########################<br />###<br />### Redirect / to /EnterpriseVault/ for Mailarchive<br />###<br />###########################<br />$wpr = spawnWebPublishingRule "Redirect Mailarchive" "Mailarchive WebListener" "$$$ISA_INTERNAL_NLB_MAILARCHIVE_IP$$$" "$$$ISA_INTERNAL_NLB_MAILARCHIVE_NAME$$$" $fpcDelegationNonePassThrough<br />$wpr.Action = 1 # Deny rule<br />$wpr.WebPublishingProperties.RedirectUrl = "https://$$$ISA_EXTERNAL_NLB_MAILARCHIVE_NAME$$$/EnterpriseVault/"<br />$wpr.WebPublishingProperties.PathMappings.Remove(1)<br />foreach ($path in @("/")) {<br />    $wpr.WebPublishingProperties.PathMappings.add("$path", $true, "$path")<br />}<br />$wpr.save()<br /><br />###########################<br />###<br />### Cold Mailarchive<br />###<br />###########################<br />$wpr = spawnWebPublishingRule "Publish Cold Mailarchive" "Mailarchive WebListener" "$$$ISA_INTERNAL_NLB_COLDMAILARCHIVE_IP$$$" "$$$ISA_INTERNAL_NLB_COLDMAILARCHIVE_NAME$$$" $fpcDelegationKerberosConstrained<br />$wpr.WebPublishingProperties.PathMappings.Remove(1)<br />foreach ($path in @("/EnterpriseVault/*")) {<br />    $wpr.WebPublishingProperties.PathMappings.add("$path", $true, "$path")<br />}<br />$wpr.WebPublishingProperties.ServicePrincipalName = "$$$SPN_EVAULT2$$$"<br />$wpr.Enabled = $false<br />$wpr.save()<br /><br />###########################<br />###<br />### ActiveSync<br />###<br />###########################<br />$wpr = spawnWebPublishingRule "Publish ActiveSync" "ActiveSync WebListener" "$$$ISA_INTERNAL_NLB_ACTIVESYNC_IP$$$" "$$$ISA_INTERNAL_NLB_ACTIVESYNC_NAME$$$" $fpcDelegationKerberosConstrained <br />$wpr.WebPublishingProperties.PathMappings.Remove(1)<br />foreach ($path in @("/Microsoft-Server-ActiveSync/*")) {<br />    $wpr.WebPublishingProperties.PathMappings.add("$path", $true, "$path")<br />}<br />$wpr.save()<br /><br />###########################<br />###<br />### AutoDiscover<br />###<br />###########################<br />$wpr = spawnWebPublishingRule "Publish Autodiscover" "Autodiscover WebListener" "$$$ISA_INTERNAL_NLB_AUTODISCOVER_IP$$$" "$$$ISA_INTERNAL_NLB_AUTODISCOVER_NAME$$$" $fpcDelegationKerberosConstrained<br />$wpr.WebPublishingProperties.TranslateLinks = $false<br />$wpr.WebPublishingProperties.PathMappings.Remove(1)<br />foreach ($path in @("/Autodiscover/*")) {<br />    $wpr.WebPublishingProperties.PathMappings.add("$path", $true, "$path")<br />}<br />$wpr.save()<br /><br /><br />###########################<br />###<br />### move "Redirect OWA" rule to the top<br />###<br />###########################<br />$denyrule = $arr.ArrayPolicy.PolicyRules | where-object { $_.name -eq "Redirect OWA"}<br />$denyruleorder = $denyrule.Order<br /><br />for ($i=$denyruleorder; $i -gt 1; $i--) {<br />    $arr.ArrayPolicy.PolicyRules.MoveUp($i)<br />}<br />$arr.save()<br /><br />###########################<br />###<br />### move "Redirect Mailarchive" rule to the top<br />###<br />###########################<br />$denyrule = $arr.ArrayPolicy.PolicyRules | where-object { $_.name -eq "Redirect Mailarchive"}<br />$denyruleorder = $denyrule.Order<br /><br />for ($i=$denyruleorder; $i -gt 1; $i--) {<br />    $arr.ArrayPolicy.PolicyRules.MoveUp($i)<br />}<br />$arr.save()<br /><br /></pre><br /><br /><b>publish_imaps_pops.ps1</b><br /><br /><pre><br />$fpcAllIPAddresses = 0<br />$fpcSpecifiedIPAddress = 2<br /><br /><br /># find our little array, reference it from $arr<br />$root = new-object -comobject "FPC.Root" -strict<br />$arr = $root.Arrays | select-object -first 1<br /><br /><br /># A new server publishing rule<br />$imaps = $arr.ArrayPolicy.PolicyRules.AddServerPublishingRule("Publish IMAPs","$$$ISA_INTERNAL_NLB_IMAPS_IP$$$", "IMAPS Server")<br /><br /># listen on the external side<br />$imaps.ServerPublishingProperties.IPsOnNetworks.Add("External", $fpcSpecifiedIPAddress, "$$$ISA_EXTERNAL_NLB_IMAPS_IP$$$")<br /><br /># and make connections appear to come from the ISA server<br />$imaps.ServerPublishingProperties.UseFirewallIPAsSource = $true<br />$imaps.save()<br /><br />$pops = $arr.ArrayPolicy.PolicyRules.AddServerPublishingRule("Publish POPs", "$$$ISA_INTERNAL_NLB_POPS_IP$$$", "POP3S Server")<br />$pops.ServerPublishingProperties.IPsOnNetworks.Add("External", $fpcSpecifiedIPAddress, "$$$ISA_EXTERNAL_NLB_POPS_IP$$$")<br />$pops.ServerPublishingProperties.UseFirewallIPAsSource = $true<br />$pops.save()<br /><br /></pre><br /><br /><b>select_network_template_and_default_policy.ps1</b><br /><br /><pre><br /># find our little array, reference it from $arr<br />$root = new-object -comobject "FPC.Root" -strict<br />$arr = $root.Arrays | select-object -first 1<br /><br /># template: Edge firewall<br /># default policy: block all<br /><br />$arr.SelectNetworkTemplateAndPolicy("Edge Firewall", "Block all")<br /></pre>
</div>


    </div>

  </body>
</html>
