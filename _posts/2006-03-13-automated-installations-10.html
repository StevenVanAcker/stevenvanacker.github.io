---
layout: post
title: automated installations (10)
date: '2006-03-13T16:35:00.000+01:00'
author: Steven Van Acker
tags: 
modified_time: '2008-01-16T09:32:47.547+01:00'
blogger_id: tag:blogger.com,1999:blog-5513234137363262204.post-4868213291839341912
blogger_orig_url: http://www.singularity.be/2006/03/automated-installations-10.html
---

It's been a while since I wrote about the automated installations project and I feel it's time for an update :)<br /><br />*female startrek voice* Last time on StarTrek Enterprise^H^H^H^H^H^H^H^H^H^H^H^H^H^H^H^H^H^H^H Automated installations <br /><br />I had made a kulnet-postfix, kulnet-ntpdate and kulnet-openntpd package. I was wondering why the postinstallation script hung when trying to restart the daemon. I dunno about that yet, but I found that not loading the debconf functions in the postinst script, fixes the problem.<br /><br />Since then, I have also made a kulnet-root-account, kulnet-snmp, kulnet-ssh, kulnet-syslog-ng, kulnet-tsm and a brand new kulnet-watchdog package. Most of these packages just either configure the underlying software correctly or add it into the kulnet-watchdog, or both. The kulnet-watchdog package contains a new software watchdog written from scratch in perl. The kulnet-tsm package is used to take daily backups to the TSM (Tivoli Storage Manager) from IBM. I also had to create Debian packages from the RPM's that are provided by IBM.<br /><br />I've currently run short on packages I can add to the default installation and I'm faced with the core of the automated installation again. Specifically, I want to be able to install Debian on a RAID 1 set. While the Sarge installer supports installing on RAID1, it does not allow you to do it with a preseeded configfile (using partman-auto). The next generation debian-installer is supposed to be able to do this (in fact, I read a <a href='http://lists.debian.org/debian-boot/2006/03/msg00450.html'>mail on the mailinglist</a> about that just today)<br /><br />Too bad I don't have the luxury to wait for Etch to become stable...<br /><br />The most logical place to start is in the debian installer itself. Since it has the capability to create and assemble RAID 1 sets manually, the code is already there. Now I just need to figure out how to automate it.<br /><br />The udeb package is called partman-md_20_all.udeb. Unpacking it shows that there is NO binary in it. Yay \o/ !<br />This means I can probably do this entire thing with whacko bash scripting.<br /><br />Sigh, again my enthousiasm was premature :(<br /><br />There is an mdadm-udeb package that contains the binary to do RAID 1.<br />However, I think I need to look at the very start of the partman suite. That's why I'm checking out the partman udeb itself.<br />I've learned that it starts by executing all files in /lib/partman/init.d/. After that it loops untill a user exits from choose_partition and then executes all files in /lib/partman/commit.d<br />Finally, all files in /lib/partman/finish.d are executed. That's where partman ends.<br /><br />Onto the init.d of partman!<br /><br />/lib/partman/init.d contains the following files which seem to do the following things:<br /><dl><br /><dt>01unsupported</dt><br /><dd>This script seems to check whether the underlying system is known and supported. If not, an error is shown.</dd><br /><dt>10umount_target</dt><br /><dd>This script checks whether /target is mounted or not. If it's mounted, it is unmounted.</dd><br /><dt>30parted</dt><br /><dd>This script starts the parted server. [Note: in definitions.sh, DEVICES=/var/lib/partman/devices] Besides that, it also moves around a couple directories but I don't know where they came from or what they are supposed to represent. I guess each directory represents an existing partition.<br /></dd><br /><dt>35dump</dt><br /><dd>This script dumps information of each partition into a logfile. Probably for debugging purposes.</dd><br /><dt>69no_media</dt><br /><dd>This one checks whether partitionable media exist and errors if there aren't</dd><br /><dt>70update_partitions</dt><br /><dd>This script reads all known partitions and invokes the scripts in /lib/partman/update.d/ for each one of them.</dd><br /><dt>71filesystems_detected</dt><br /><dd>This script does nothing but create an empty file called /var/lib/partman/filesystems_detected. Probably just a way to tell later scripts to be careful about existing partitions.</dd><br /><dt>95backup</dt><br /><dd>This script makes a backup of /var/lib/partman/devices. Probably to have a copy before changing things that can get screwed up</dd><br /></dl><br /><br />All of this seems to be just preparation. <br />The directory /var/lib/partman/devices seems to be a parallel status directory to keep track of the partitions. I wouldn't be surprised if changes are made to this directory first untill the user is satisfied and then all the changes can be processed at the end.<br /><br />The scripts called by 70update_partitions in /lib/partman/update.d are the following:<br /><br /><dl><br /><dt>20bootable</dt><br /><dd>This script checks whether a partitions bootable flag is set. It also updates the status dir</dd><br /><dt>20detected_filesystem</dt><br /><dd>This one checks for existing partitions and marks the status dir</dd><br /><dt>59default_visuals</dt><br /><dd>This script fetches a human readable description of the filesystem on the given partition and stores it in the status dir</dd><br /><dt>80visual</dt><br /><dd>This script calls all scripts in /lib/partman/valid_visuals.d and parses the output of all those scripts. The output is one of grep "number","type","size","name","filesystem","bootable","method" or "mountpoint". For each of these output "words", a script exists: /lib/partman/visual.d/[name], which is called if that name appears in the output of the previous script. The output of THESE scripts is then stored in a file called "view"</dd><br /></dl><br /><br />We just keep getting deeper and deeper in nested script calls...<br />I'll take the red pill and see how deep the rabbithole goes &lt;/matrix&gt;<br /><br />/lib/partman/valid_visuals.d seems to contain these scripts:<br /><dl><br /><dt>05number</dt><br /><dd>prints "number\tPartition number\n"</dd><br /><dt>10type</dt><br /><dd>prints "type\tType - primary or logical\n" if parted returns yes for USES_EXTENDED</dd><br /><dt>15size</dt><br /><dd>prints "size\tSize\n"</dd><br /><dt>20bootable</dt><br /><dd>prints "bootable\tThe bootable flag\n"</dd><br /><dt>25method</dt><br /><dd>prints "method\tUsage method: F - format K - keep and use existing data\n"</dd><br /><dt>30parted_fs</dt><br /><dd>prints "parted_fs\tThe file system as known by parted\n"</dd><br /><dt>35filesystem</dt><br /><dd>prints "filesystem\tFile system\n"</dd><br /><dt>40name</dt><br /><dd>prints "name\tName\n" if the partition uses named partitions</dd><br /><dt>45mountpoint</dt><br /><dd>prints "mountpoint\tMount point\n"</dd><br /></dl><br /><br />Most of these lines are printed, except for "type" and "name" which depend on a test.<br /><br />The scripts in /lib/partman/visual.d are:<br /><dl><br /><dt>bootable</dt><br /><dd/><br /><dt>filesystem</dt><br /><dd/><br /><dt>method</dt><br /><dd/><br /><dt>mountpoint</dt><br /><dd/><br /><dt>name</dt><br /><dd/><br /><dt>number</dt><br /><dd/><br /><dt>parted_fs</dt><br /><dd/><br /><dt>size</dt><br /><dd/><br /><dt>type</dt><br /><dd/><br /></dl><br /><br />I'm not gonna sum up what these scripts print. Suffice it to say that they look at the terminal type and print something visually pleasing. This output is probably used when showing the contents of a partition in partman.<br /><br />In case you forgot, we're still at the end of /lib/partman/init.d...<br /><br />At this point, the partman script loops over "ask_user /lib/partman/choose_partition" and asks to confirm changes when the user is done.<br /><br />The ask_user function located in definitions.sh looks like this:<br /><br /><pre><br />ask_user () {<br />    local IFS dir template priority default choices plugin name option<br />    dir="$1"; shift<br />    template=$(cat $dir/question)<br />    priority=$(cat $dir/priority)<br />    if [ -f $dir/default_choice ]; then<br />        default=$(cat $dir/default_choice)<br />    else<br />        default=""<br />    fi<br />    choices=$(<br />        for plugin in $dir/*; do<br />            [ -d $plugin ] || continue<br />            name=$(basename $plugin)<br />            IFS="$NL"<br />            for option in $($plugin/choices "$@"); do<br />                printf "%s__________%s\n" $name "$option"<br />            done<br />            restore_ifs<br />        done<br />    )<br />    code=0<br />    debconf_select $priority $template "$choices" "$default" || code=$?<br />    if [ $code -ge 100 ]; then return 255; fi<br />    echo "$RET" &gt;$dir/default_choice<br />    $dir/${RET%__________*}/do_option ${RET#*__________} "$@" || return $?<br />    return 0<br />}<br /></pre><br /><br />This is the first reference to plugins I've found so far.<br />