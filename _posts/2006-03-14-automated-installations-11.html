---
layout: post
title: automated installations (11)
date: '2006-03-14T23:23:00.000+01:00'
author: Steven Van Acker
tags: 
modified_time: '2008-01-20T23:24:04.137+01:00'
blogger_id: tag:blogger.com,1999:blog-5513234137363262204.post-4009728742130122297
blogger_orig_url: http://www.singularity.be/2006/03/automated-installations-11.html
---

This is getting to be one long article.<br />I'm thinking of making it a static page once I've researched everything and finished the project.<br />(I've actually created a special category for the articles concerning the automated installations project)<br /><br />Yesterday I stumbled across the ask_user function. It contains the first reference to plugins I've found so far. For each plugin, the ask_user function executes the "choices" script and uses the output to construct a list of choices for the debconf_select function:<br /><br /><pre><br />debconf_select () {<br />        local IFS priority template choices default_choice default x u newchoices code<br />        priority="$1"<br />        template="$2"<br />        choices="$3"<br />        default_choice="$4"<br />        default=''<br />        # Debconf ignores spaces so we have to remove them from $choices<br />        newchoices=''<br />        IFS="$NL"<br />        for x in $choices; do<br />                local key option<br />                restore_ifs<br />                key=$(echo ${x%$TAB*})<br />                # work around bug #243373<br />                if [ "$TERM" = xterm -o "$TERM" = bterm ]; then<br />                        debconf_select_lead="$NBSP"<br />                else<br />                        debconf_select_lead="> "<br />                fi<br />                option=$(echo "${x#*$TAB}" | sed 's/ *$//g' | sed "s/^ /$debconf_select_lead/g")<br />                newchoices="${newchoices}${NL}${key}${TAB}${option}"<br />                if [ "$key" = "$default_choice" ]; then<br />                    default="$option"<br />                fi<br />        done<br />        choices="$newchoices"<br />        u=''<br />        IFS="$NL"<br />        # escape the commas and leading whitespace but keep them unescaped<br />        # in $choices<br />        for x in $choices; do<br />                u="$u, `echo ${x#*$TAB} | sed 's/,/\\\\,/g' | sed 's/^ /\\\\ /'`"<br />        done<br />        u=${u#, }<br />        if [ -n "$default" ]; then<br />                db_set $template "$default"<br />        fi<br />        db_subst $template CHOICES "$u"<br />        code=0<br />        db_input $priority $template || code=1<br />        db_go || return 255<br />        db_get $template<br />        IFS="$NL"<br />        for x in $choices; do<br />                if [ "$RET" = "${x#*$TAB}" ]; then<br />                        RET="${x%$TAB*}"<br />                        break<br />                fi<br />        done<br />        return $code<br />}<br /></pre><br /><br />The debconf_select function presents a menu to the user using the given template. In this specific case, it's the template "partman/choose_partition":<br /><br /><pre><br />Template: partman/choose_partition<br />Type: select<br />Choices: ${CHOICES}<br />Description: This is an overview of your currently configured partitions and mount points. <br /> Select a partition to modify its settings (file system, mount point, etc.), a free space <br /> to create partitions, or a device to initialise its partition table.<br />...<br /></pre><br /><br />This looks like the following screen:<br />[img_assist|fid=1017722|thumb=1|alt=6182_large.png]<br /><br /><br />The first line there "Configure software RAID" is inserted into choose_partition.d by the partman-md udeb.<br /><br />After the user makes a selection, debconf_select() returns to ask_user. This last one stores the selection in $dir/default_choice so it can remember it later.<br />Then, the script "do_option" is called.<br /><br />do_option starts by calling confirm_changes() which seems to do nothing but ask the user to confirm  that changed partitions will be committed. It then commits those changes and restarts parted_server. [Actually, thats what the comment says. In fact, the script sends a QUIT to the parted_server and then deletes the pidfile. I don't see it restarted here...]<br /><br />Next, mdcfg is started. This tool resides in the mdcfg-utils udeb.<br />When mdcfg is finished, all the scripts in /lib/partman/init.d are called again.<br /><br />Let's have a look at this mdcfg (which is luckily a bash script)<br />Seems like I'm finally getting to the good stuff.<br /><br />The mdcfg script loads the MD and RAID modules, detects and starts MD devices with mdrun, installs the mdadm tool in /target and then calls the md_mainmenu() function.<br /><br /><pre><br />### Main of script ###<br /><br /># Try to load the necesarry modules.<br /># Supported schemes: RAID 0, RAID 1, RAID 5<br />depmod -a 1>/dev/null 2>&1<br />modprobe md 1>/dev/null 2>&1<br />modprobe raid0 >/dev/null 2>&1<br />modprobe raid1 1>/dev/null 2>&1<br />modprobe raid5 >/dev/null 2>&1<br /><br /># Try to detect MD devices, and start them<br />/sbin/mdrun<br /><br /># Make sure that we have md-support<br />if [ ! -e /proc/mdstat ]; then<br />        db_set mdcfg/nomd "false"<br />        db_input high mdcfg/nomd<br />        db_go<br />        db_stop<br />        exit 0<br />fi<br /><br /># Force mdadm to be installed on the target system<br />apt-install mdadm<br /><br /># We want the "go back" button<br />#db_capb backup<br /><br />md_mainmenu<br /><br />#db_stop<br />exit 0<br /></pre><br /><br />md_mainmenu() calls md_createmain() which calls md_create_raid1(). That last one asks the user a bunch of questions about hwo to configure the RAID1 and then calls mdadm to create the RAID1.<br />It's important to keep in mind that the partitions already need to exist before a RAID1 can be laid out over them.<br /><br />The more I read all this code, the more I feel like trimming it down to the bear essentials.<br />I don't need all this user-input to do an automated install. Basically, I can have 2 partitioning schemes: either a simple swap + /boot + / on 1 disk, or 3 RAID 1 devices on 2 disks.<br />The sizes are pretty much fixed: 64MB for /boot, 2*RAM for swap and the rest for the root disk.<br /><br />To do all of this "My Way" (TM), I need to pre-empt the whole partman business. Which means my script will have to expect the same input (or less specific input), and produce the same output (or more specific output). Reminds me of Liskov :)<br /><br />I'm gonna finish this journey first though. Understanding partman is essential to rewriting it.<br />We're pretty deep inside the rabbithole at the moment. The mdcfg tool was called by the do_option script of the partman-md plugin. That last one was invoked by ask_user in partman.<br /><br />The next step is calling all scripts in commit.d, followed by those in finish.d.<br /><br />At first glance, the scripts in commit.d don't do that much:<br /><dl><br /><dt>10filesystems_changed</dt><br /><dd>Removes /var/lib/partman/filesystems_detected</dd><br /><dt>20remove_backup</dt><br /><dd>Removes /var/lib/partman/backup</dd><br /><dt>30parted</dt><br /><dd>Disables swap and sends a "COMMIT" to parted_server</dd><br /><dt>32update-dev</dt><br /><dd>This calls the program "update-dev" if it exists. The program seems to be part of udevfs (I can't find the package at all, and it doesn't look like it was installed in the debian-installer I'm using)</dd><br /></dl><br /><br />There is only 1 script in finish.d, which kills the parted_server.<br /><br />All other scripts are inserted by other udeb packages.<br /><br />These scripts are added by several udeb packages in /lib/partman/init.d:<br /><dl><br /><dt>01unsupported</dt><br /><dt><em>03kernelmodules_basicfilesystems</em></dt><br /><dt><em>03kernelmodules_ext3</em></dt><br /><dt><em>03kernelmodules_jfs</em></dt><br /><dt><em>03kernelmodules_reiserfs</em></dt><br /><dt><em>03kernelmodules_xfs</em></dt><br /><dd>All the 03kernelmodules_* scripts seem to check if modules are loaded and load them if required. They also touch a status file in /var/lib/partman, no doubt to indicate the presence of the module.</dd><br /><dt>10umount_target</dt><br /><dt>30parted</dt><br /><dt><em>31md-devices</em></dt><br /><dd>I'm guessing this script looks at existing MD devices and dumps them into /var/lib/partman (the status directory)</dd><br /><dt>35dump</dt><br /><dt><em>50lvm</em></dt><br /><dd>The comment at the start of this file says: "This script sets method lvm for all partitions that have the lvm flag set. It also discovers the logical volumes and creates in them a loop partition table and partition.</dd><br /><dt><em>51md</em></dt><br /><dd>This scripts goes over all MD devices and marks them as being RAID</dd><br /><dt>69no_media</dt><br /><dt>70update_partitions</dt><br /><dt>71filesystems_detected</dt><br /><dt><em>80autouse_swap</em></dt><br /><dd>Detects and prepares swap partitions</dd><br /><dt>95backup</dt><br /><dt><em>99initial_auto</em></dt><br /><dd>Initialisation for partman-auto</dd><br /></dl><br /><br />It doesn't look like partman-auto can autopartition multiple devices :(<br />So I think I'll have to provide my own way of partitioning the disks.<br />Looking at the control file for partman, I find:<br /><pre><br />Provides: made-filesystems, mounted-partitions, partitioned-harddrives, created-fstab<br /></pre><br /><br />My guess is that, if I replace partman, I need to partition the harddrives, make the filesystems, mount them and create an /etc/fstab.<br /><br />After a welldeserved break, I decided a practical test was in order. I modified partman so it would do nothing at all (That is: it would check for a file /done every second untill it found one, and then exit 0)<br />Then, I logged into the second terminal, created a partition table with sfdisk, created a filesystem and mounted it under /target. Then I touched /done and the installation continued.<br />To my surprise, the base system was installed and the machine rebooted. However, it couldn't find init... I screwed something up :)<br /><br />/target/etc/fstab contains:<br /><pre><br /># UNCONFIGURED FSTAB FOR BASE SYSTEM<br /></pre><br /><br />Looking at the logs, the installer complained that /etc/fstab and /etc/mtab could not be found, /proc was not mounted and it couldn't find mdadm.<br />All valid errors I suppose.<br /><br />Let's see how the real install CD creates these files...<br /><br />/etc/fstab contains:<br /><pre><br /># /etc/fstab: static file system information<br />#<br /># <file system> <mount point> <type> <options> <dump> <pass><br />proc          /proc            proc    defaults                   0 0<br />/dev/sda1     /                ext3    defaults,errors=remount-ro 0 1<br />/dev/sda5     none             swap    sw                         0 0<br />/dev/hdc      /media/cdrom0    iso9660 ro,user,noauto             0 0<br />/dev/fd0      /media/floppy0   auto    rw,user,noauto             0 0<br /># UNCONFIGURED FSTAB FOR BASE SYSTEM<br /></pre><br /><br />/etc/mtab contains:<br /><pre><br />/dev/sda1 /     ext3 rw,errors=remount-ro 0 0<br />proc      /proc proc rw                   0 0<br /></pre><br /><br />The Debian install CD also complains about not finding mdadm.<br /><br />I manually created an /etc/fstab right before touching /done (VMWare snapshots are great) and gets a little bit further this time. The problem now is that the disk is mounted readonly.<br /><br />Removing the "errors=remount-ro" from /etc/fstab fixed the problem, but its no solution.<br />I need to figure out why my manually created partition causes an error.<br /><br />To find out what is so different, I tracked down the reboot command so I can delay it while I look for the answers. The script /usr/lib/prebaseconfig.d/99reboot is responsible for that. Adding a sleep or so in it, should delay it a bit.<br /><br />In /etc/rcS.d, these scripts are executed (among others):<br />mountall.sh,discover,mountvirtfs<br /><br />Mountvirtfs is done first, then mountall.sh, discover and mountvirtfs again.<br />Right before discover, the first error appears meaning the problem is somewhere in mountall.sh<br />Apparently, the errors happen when the filesystem is being cleaned up (/tmp and /var/tmp and such)