---
layout: post
title: PIC16f627A with RS232 and sdcc
date: '2009-07-06T08:01:00.003+02:00'
author: Steven Van Acker
tags:
- English
- Ubuntu
- PIC
- Building Stuff
modified_time: '2009-07-06T08:18:42.094+02:00'
blogger_id: tag:blogger.com,1999:blog-5513234137363262204.post-455091317683491985
blogger_orig_url: http://www.singularity.be/2009/07/pic16f627a-with-rs232-and-sdcc.html
---

<!-- StevensBlogSpotFilterThing<br />Programming PICs in assembly can be challenging, but it gets to be a drag after a while. Especially when doing serial communications you start wondering: "wouldn't it be great if all this fiddly crap was in some kind of library ?"<br /><br />I've been playing with sdcc (Small Device C Compiler) to write code for the PIC. Unfortunately at the time I was playing with it (in the middle of exams), there was no library code to do RS232 for the 16f627a (at least not in a blatantly obvious way). So instead of asking for directions like any sane person would do, I dove right in and wrote it myself.<br /><br />Now that I've upgraded to Ubuntu Jaunty (which is such a resource hog btw), I wonder if the sdcc people have included some code for the 16f627a but haven't checked.<br /><br />In any case, I'll post the code here for all of you to laugh at and for me to have a backup for when my harddisk dies (any minute now)<br /><br />lib.h:<br /><br />[PRE]<br />#ifndef __LIB_H<br />#define __LIB_H<br /><br />#define USART_TX_INT_ON   0xff<br />#define USART_TX_INT_OFF  0x7f<br /><br />#define USART_RX_INT_ON   0xff<br />#define USART_RX_INT_OFF  0xbf<br /><br />#define USART_BRGH_HIGH   0xff<br />#define USART_BRGH_LOW    0xef<br /><br />#define USART_CONT_RX     0xff<br />#define USART_SINGLE_RX   0xf7<br /><br />#define USART_SYNC_MASTER 0xff<br />#define USART_SYNC_SLAVE  0xfb<br /><br />#define USART_NINE_BIT    0xff<br />#define USART_EIGHT_BIT   0xfd<br /><br />#define USART_SYNCH_MODE  0xff<br />#define USART_ASYNCH_MODE 0xfe<br /><br />void usart_open(unsigned char, unsigned int);<br /><br />void usart_putc(unsigned char);<br />unsigned char usart_getc(void);<br /><br />unsigned char usart_busy(void);<br />unsigned char usart_drdy(void);<br /><br />unsigned char usart_wait_and_read(void);<br />void usart_wait_and_write(unsigned char);<br /><br />#endif /* __LIB_H */<br />[/PRE]<br /><br />lib.c:<br />[PRE]<br />#include &lt;pic/pic16f627a.h&gt;<br />#include "lib.h"<br /><br />void usart_open(unsigned char config, unsigned int spbrg) { /* {{ "{{" }}{ */<br />  TXSTA = 0;           // Reset USART registers to POR state<br />  RCSTA = 0;<br /> <br />  if(config & ~USART_ASYNCH_MODE)<br />   SYNC = 1;<br /><br />  if(config & ~USART_EIGHT_BIT) {<br />    TX9 = 1;<br />    RX9 = 1;<br />  }<br /><br />  if(config & ~USART_SYNC_SLAVE)<br />    CSRC = 1;<br /><br />  /*<br />  if(config & ~USART_SINGLE_RX)<br />    CREN = 1;<br />  else <br />    SREN = 1;<br />  */<br /><br />  CREN = 1;<br />  SREN = 1;<br /><br />  if(config & ~USART_BRGH_LOW)<br />    BRGH = 1;<br />  else <br />    BRGH = 0;<br /><br />  /* TX interrupts */<br />  TXIF = 0;<br /><br />  if(config & ~USART_RX_INT_OFF)<br />    RCIE = 1;<br />  else <br />    RCIE = 0;<br /><br />  /* RX interrupts */<br />  RCIF = 0;<br /><br />  if(config & ~USART_TX_INT_OFF)<br />    TXIE = 1;<br />  else <br />    TXIE = 0;<br /><br />  SPBRG = (char)spbrg;<br /><br />  TXEN = 1;<br />  SPEN = 1;<br /><br />  TRISB1 = 1;  // set B1 to transmit<br />  TRISB2 = 0;  // set B2 to receive<br />}<br />/* }}} */<br /><br />void usart_putc(unsigned char dat) { /* {{ "{{" }}{ */<br />  //if(TX9) {<br />  //  TX9D = 0;<br />  //  if(USART_Status.TX_NINE)<br />  //    TX9D = 1;<br />  //}<br /><br />  TXREG = dat;      // Write the data byte to the USART<br />}<br />/* }}} */<br />unsigned char usart_getc(void) { /* {{ "{{" }}{ */<br />  return RCREG;<br />}<br />/* }}} */<br /><br />unsigned char usart_busy(void) { /* {{ "{{" }}{ */<br />  return !TRMT;<br />}<br />/* }}} */<br />unsigned char usart_drdy(void) { /* {{ "{{" }}{ */<br />    return RCIF;<br />}<br />/* }}} */<br /><br />unsigned char usart_wait_and_read(void) { /* {{ "{{" }}{ */<br />    while(!usart_drdy());<br />    return usart_getc();<br />} <br />/* }}} */<br />void usart_wait_and_write(unsigned char dat) { /* {{ "{{" }}{ */<br />    while(usart_busy());<br />    usart_putc(dat);<br />}<br />/* }}} */<br />[/PRE]<br /><br />test.c :<br />[PRE]<br />#include &lt;pic/pic16f627a.h&gt;<br />#include "lib.h"<br /><br />#define GPSIM_20Mhz_2400baud_BRGHlow 0x81<br />#define GPSIM_20Mhz_9600baud_BRGHlow 0x20<br /><br />#define PIC_4Mhz_2400baud_BRGHlow 0x19<br />#define PIC_4Mhz_9600baud_BRGHhigh 0x19<br /><br />static __code unsigned short __at(0x2007) _conf = _INTRC_OSC_NOCLKOUT;<br /><br />unsigned char data_num[] = {<br />    0x3f, 0x06, 0x5b, 0x4f, 0x66, 0x6d, 0x7d, 0x07, 0x7f, 0x6f<br />};<br /><br />unsigned char data_alpha[] = {<br />    0x77, 0x7c, 0x58, 0x5e, 0x79, 0x71<br />};<br /><br />//unsigned char hex[] = "0123456789ABCDEF"; <- this doesn't work yet<br />unsigned char hex[] = {<br />    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'<br />};<br /><br />void main()<br />{<br />    unsigned char c = 'G';<br />    usart_open(USART_TX_INT_OFF & USART_RX_INT_OFF & USART_ASYNCH_MODE & USART_BRGH_LOW & USART_EIGHT_BIT, GPSIM_20Mhz_2400baud_BRGHlow);<br /><br />    TRISA = 0;<br /><br />    for (;;)<br />    {<br /> c = usart_wait_and_read();<br /><br /> if(c >= 'A' && c <= 'F') {<br />     PORTA = data_alpha[c - 'A'];<br /> } else {<br />     if(c >= '0' && c <= '9')<br />         PORTA = data_num[c - '0'];<br /> }<br /><br /> usart_wait_and_write(c);<br /> usart_wait_and_write(':');<br /> usart_wait_and_write(' ');<br /> usart_wait_and_write('0');<br /> usart_wait_and_write('x');<br /> usart_wait_and_write(hex[(c & 0xf0) >> 4]);<br /> usart_wait_and_write(hex[c & 0x0f]);<br /> usart_wait_and_write('\n');<br />    }<br />}<br />[/PRE]<br /><br />env.conf :<br />[PRE]<br /># load the gpsim modules library. <br />module lib /usr/lib/libgpsim_modules.so.0.0.0<br /><br /># creating an usart and connecting its TX pin to the PICs RX pin, allowing keyboard input<br />module load usart U1<br />node nct<br />node ncr<br />attach nct pin(portb1) U1.TXPIN<br />attach ncr pin(portb2) U1.RXPIN<br />U1.console = true<br />U1.rxbaud = 2400<br />U1.txbaud = 2400<br /><br /># creating a 7 segment led display and hooking it up to PORTA<br />module load led_7segments L7<br />node nl0 nl1 nl2 nl3 nl4 nl5 nl6<br />attach nl0 pin(porta0) L7.seg0<br />attach nl1 pin(porta1) L7.seg1<br />attach nl2 pin(porta2) L7.seg2<br />attach nl3 pin(porta3) L7.seg3<br />attach nl4 pin(porta4) L7.seg4<br />attach nl5 pin(porta5) L7.seg5<br />attach nl6 pin(porta6) L7.seg6<br /><br /># tell the builtin scope in gpsim to monitor portb2<br /># (in gpsim: Windows -> Scope)<br />scope.ch0="portb1"<br />[/PRE]<br /><br />Makefile :<br />[PRE]<br />test.hex: test.o lib.o<br /> gplink \<br />         -c \<br />  -s /usr/share/gputils/lkr/16f627a.lkr \<br />         -o $@ \<br />         -m \<br />         $^ \<br />         -I /usr/share/sdcc/lib/pic \<br />         pic16f627a.lib libsdcc.lib<br /><br />test.o: test.asm<br /> gpasm -c $&lt;<br /><br />lib.o: lib.asm<br /> gpasm -c $&lt;<br /><br />test.asm: test.c<br /> sdcc -S -mpic14 -p16f627a $&lt;<br /><br />lib.asm: lib.c<br /> sdcc -S -mpic14 -p16f627a $&lt;<br /><br />run:<br /> gpsim -c env.conf -s test.cod<br /><br />clean:<br /> rm -f *.cod *.hex *.lst *~ *.o *.asm *.cof *.map<br /><br />upload:<br /> ../K8048/k14 p test.hex<br /> ../K8048/k14 v test.hex<br />[/PRE]<br /><br />The code in test.c does RS232 in both directions. It takes a character and sends out the hex code for it. In addition, if the character is a hex digit (0123456789ABCDEF), it gets displayed on the 7 digit led display.<br /><br />StevensBlogSpotFilterThing --><br />Programming PICs in assembly can be challenging, but it gets to be a drag after a while. Especially when doing serial communications you start wondering: "wouldn't it be great if all this fiddly crap was in some kind of library ?"<br /><br />I've been playing with sdcc (Small Device C Compiler) to write code for the PIC. Unfortunately at the time I was playing with it (in the middle of exams), there was no library code to do RS232 for the 16f627a (at least not in a blatantly obvious way). So instead of asking for directions like any sane person would do, I dove right in and wrote it myself.<br /><br />Now that I've upgraded to Ubuntu Jaunty (which is such a resource hog btw), I wonder if the sdcc people have included some code for the 16f627a but haven't checked.<br /><br />In any case, I'll post the code here for all of you to laugh at and for me to have a backup for when my harddisk dies (any minute now)<br /><br />lib.h:<br /><br /><pre style="background-color: #EEEEEE; border: black 1px dashed; line-height: 100%; padding: 10px;"><br />#ifndef __LIB_H<br />#define __LIB_H<br /><br />#define USART_TX_INT_ON   0xff<br />#define USART_TX_INT_OFF  0x7f<br /><br />#define USART_RX_INT_ON   0xff<br />#define USART_RX_INT_OFF  0xbf<br /><br />#define USART_BRGH_HIGH   0xff<br />#define USART_BRGH_LOW    0xef<br /><br />#define USART_CONT_RX     0xff<br />#define USART_SINGLE_RX   0xf7<br /><br />#define USART_SYNC_MASTER 0xff<br />#define USART_SYNC_SLAVE  0xfb<br /><br />#define USART_NINE_BIT    0xff<br />#define USART_EIGHT_BIT   0xfd<br /><br />#define USART_SYNCH_MODE  0xff<br />#define USART_ASYNCH_MODE 0xfe<br /><br />void usart_open(unsigned char, unsigned int);<br /><br />void usart_putc(unsigned char);<br />unsigned char usart_getc(void);<br /><br />unsigned char usart_busy(void);<br />unsigned char usart_drdy(void);<br /><br />unsigned char usart_wait_and_read(void);<br />void usart_wait_and_write(unsigned char);<br /><br />#endif /* __LIB_H */<br /></pre><br /><br />lib.c:<br /><pre style="background-color: #EEEEEE; border: black 1px dashed; line-height: 100%; padding: 10px;"><br />#include &lt;pic/pic16f627a.h&gt;<br />#include "lib.h"<br /><br />void usart_open(unsigned char config, unsigned int spbrg) { /* {{ "{{" }}{ */<br />  TXSTA = 0;           // Reset USART registers to POR state<br />  RCSTA = 0;<br /> <br />  if(config & ~USART_ASYNCH_MODE)<br />   SYNC = 1;<br /><br />  if(config & ~USART_EIGHT_BIT) {<br />    TX9 = 1;<br />    RX9 = 1;<br />  }<br /><br />  if(config & ~USART_SYNC_SLAVE)<br />    CSRC = 1;<br /><br />  /*<br />  if(config & ~USART_SINGLE_RX)<br />    CREN = 1;<br />  else <br />    SREN = 1;<br />  */<br /><br />  CREN = 1;<br />  SREN = 1;<br /><br />  if(config & ~USART_BRGH_LOW)<br />    BRGH = 1;<br />  else <br />    BRGH = 0;<br /><br />  /* TX interrupts */<br />  TXIF = 0;<br /><br />  if(config & ~USART_RX_INT_OFF)<br />    RCIE = 1;<br />  else <br />    RCIE = 0;<br /><br />  /* RX interrupts */<br />  RCIF = 0;<br /><br />  if(config & ~USART_TX_INT_OFF)<br />    TXIE = 1;<br />  else <br />    TXIE = 0;<br /><br />  SPBRG = (char)spbrg;<br /><br />  TXEN = 1;<br />  SPEN = 1;<br /><br />  TRISB1 = 1;  // set B1 to transmit<br />  TRISB2 = 0;  // set B2 to receive<br />}<br />/* }}} */<br /><br />void usart_putc(unsigned char dat) { /* {{ "{{" }}{ */<br />  //if(TX9) {<br />  //  TX9D = 0;<br />  //  if(USART_Status.TX_NINE)<br />  //    TX9D = 1;<br />  //}<br /><br />  TXREG = dat;      // Write the data byte to the USART<br />}<br />/* }}} */<br />unsigned char usart_getc(void) { /* {{ "{{" }}{ */<br />  return RCREG;<br />}<br />/* }}} */<br /><br />unsigned char usart_busy(void) { /* {{ "{{" }}{ */<br />  return !TRMT;<br />}<br />/* }}} */<br />unsigned char usart_drdy(void) { /* {{ "{{" }}{ */<br />    return RCIF;<br />}<br />/* }}} */<br /><br />unsigned char usart_wait_and_read(void) { /* {{ "{{" }}{ */<br />    while(!usart_drdy());<br />    return usart_getc();<br />} <br />/* }}} */<br />void usart_wait_and_write(unsigned char dat) { /* {{ "{{" }}{ */<br />    while(usart_busy());<br />    usart_putc(dat);<br />}<br />/* }}} */<br /></pre><br /><br />test.c :<br /><pre style="background-color: #EEEEEE; border: black 1px dashed; line-height: 100%; padding: 10px;"><br />#include &lt;pic/pic16f627a.h&gt;<br />#include "lib.h"<br /><br />#define GPSIM_20Mhz_2400baud_BRGHlow 0x81<br />#define GPSIM_20Mhz_9600baud_BRGHlow 0x20<br /><br />#define PIC_4Mhz_2400baud_BRGHlow 0x19<br />#define PIC_4Mhz_9600baud_BRGHhigh 0x19<br /><br />static __code unsigned short __at(0x2007) _conf = _INTRC_OSC_NOCLKOUT;<br /><br />unsigned char data_num[] = {<br />    0x3f, 0x06, 0x5b, 0x4f, 0x66, 0x6d, 0x7d, 0x07, 0x7f, 0x6f<br />};<br /><br />unsigned char data_alpha[] = {<br />    0x77, 0x7c, 0x58, 0x5e, 0x79, 0x71<br />};<br /><br />//unsigned char hex[] = "0123456789ABCDEF"; <- this doesn't work yet<br />unsigned char hex[] = {<br />    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'<br />};<br /><br />void main()<br />{<br />    unsigned char c = 'G';<br />    usart_open(USART_TX_INT_OFF & USART_RX_INT_OFF & USART_ASYNCH_MODE & USART_BRGH_LOW & USART_EIGHT_BIT, GPSIM_20Mhz_2400baud_BRGHlow);<br /><br />    TRISA = 0;<br /><br />    for (;;)<br />    {<br /> c = usart_wait_and_read();<br /><br /> if(c >= 'A' && c <= 'F') {<br />     PORTA = data_alpha[c - 'A'];<br /> } else {<br />     if(c >= '0' && c <= '9')<br />         PORTA = data_num[c - '0'];<br /> }<br /><br /> usart_wait_and_write(c);<br /> usart_wait_and_write(':');<br /> usart_wait_and_write(' ');<br /> usart_wait_and_write('0');<br /> usart_wait_and_write('x');<br /> usart_wait_and_write(hex[(c & 0xf0) >> 4]);<br /> usart_wait_and_write(hex[c & 0x0f]);<br /> usart_wait_and_write('\n');<br />    }<br />}<br /></pre><br /><br />env.conf :<br /><pre style="background-color: #EEEEEE; border: black 1px dashed; line-height: 100%; padding: 10px;"><br /># load the gpsim modules library. <br />module lib /usr/lib/libgpsim_modules.so.0.0.0<br /><br /># creating an usart and connecting its TX pin to the PICs RX pin, allowing keyboard input<br />module load usart U1<br />node nct<br />node ncr<br />attach nct pin(portb1) U1.TXPIN<br />attach ncr pin(portb2) U1.RXPIN<br />U1.console = true<br />U1.rxbaud = 2400<br />U1.txbaud = 2400<br /><br /># creating a 7 segment led display and hooking it up to PORTA<br />module load led_7segments L7<br />node nl0 nl1 nl2 nl3 nl4 nl5 nl6<br />attach nl0 pin(porta0) L7.seg0<br />attach nl1 pin(porta1) L7.seg1<br />attach nl2 pin(porta2) L7.seg2<br />attach nl3 pin(porta3) L7.seg3<br />attach nl4 pin(porta4) L7.seg4<br />attach nl5 pin(porta5) L7.seg5<br />attach nl6 pin(porta6) L7.seg6<br /><br /># tell the builtin scope in gpsim to monitor portb2<br /># (in gpsim: Windows -> Scope)<br />scope.ch0="portb1"<br /></pre><br /><br />Makefile :<br /><pre style="background-color: #EEEEEE; border: black 1px dashed; line-height: 100%; padding: 10px;"><br />test.hex: test.o lib.o<br /> gplink \<br />         -c \<br />  -s /usr/share/gputils/lkr/16f627a.lkr \<br />         -o $@ \<br />         -m \<br />         $^ \<br />         -I /usr/share/sdcc/lib/pic \<br />         pic16f627a.lib libsdcc.lib<br /><br />test.o: test.asm<br /> gpasm -c $&lt;<br /><br />lib.o: lib.asm<br /> gpasm -c $&lt;<br /><br />test.asm: test.c<br /> sdcc -S -mpic14 -p16f627a $&lt;<br /><br />lib.asm: lib.c<br /> sdcc -S -mpic14 -p16f627a $&lt;<br /><br />run:<br /> gpsim -c env.conf -s test.cod<br /><br />clean:<br /> rm -f *.cod *.hex *.lst *~ *.o *.asm *.cof *.map<br /><br />upload:<br /> ../K8048/k14 p test.hex<br /> ../K8048/k14 v test.hex<br /></pre><br /><br />The code in test.c does RS232 in both directions. It takes a character and sends out the hex code for it. In addition, if the character is a hex digit (0123456789ABCDEF), it gets displayed on the 7 digit led display.