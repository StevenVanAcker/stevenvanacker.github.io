---
layout: post
title: automated installations (3)
date: '2006-02-14T23:06:00.000+01:00'
author: Steven Van Acker
tags: 
modified_time: '2008-01-20T23:10:47.859+01:00'
blogger_id: tag:blogger.com,1999:blog-5513234137363262204.post-5552385535242078762
blogger_orig_url: http://www.singularity.be/2006/02/automated-installations-3.html
---

I got a reply from the debian-boot mailinglist that partman-auto indeed has a bug. So I thought about it and decided I would try to find this bug instead of <br />going ahead and writing my own partitioner. For 2 reasons: first, if the bug is fixed, I don't need to write custom software and the current software will be<br /> maintained without me having to put effort in it. Second, if this bug is solved, maybe others will benefit from it too.<br /><br />I must say, while I'm trying to understand this code, I'm learning a few things about shell programming. I'm also noticing the hard way why global variables <br />are a bad thing.<br /><br />I started today's journey by looking at "decode_recipe()". What it does is read a recipe file, parse it and return everything in environment variables. More <br />precise:<br /><br /><pre><br />decode_recipe () {<br />    local ram line word min factor max fs -<br />    unnamed=$(($unnamed + 1))<br />    ram=$(grep ^Mem: /proc/meminfo | { read x y z; echo $y; }) # in bytes<br />    if [ -z "$ram" ]; then<br />        ram=$(grep ^MemTotal: /proc/meminfo | { read x y z; echo $y; })000<br />    fi<br />    ram=$(expr 0000000"$ram" : '0*\(..*\)......$') # convert to megabytes<br />    name="Unnamed.${unnamed}"<br />    scheme=''<br />    line=''<br /></pre><br /><br />In this initialisation, it fetches the amount of RAM you have from /proc/meminfo. "$ram" now contains the amount of megabytes of RAM you have.<br /><br /><pre><br />    for word in $(cat $1); do<br /></pre><br /><br />Now, for start processing each "word" in the file passed as the first argument.<br />This thing is a statemachine. "$word" will contain the last read word, while "$line" will contain the line built up so far.<br /><br /><pre><br />        case $word in<br />            :)<br />                name=$line<br />                line=''<br />                ;;<br /></pre><br /><br />Everything since the last line is stored in "$name" if a ":" is encountered. For example "my little recipe : ..." will store "my little recipe" in "$name"<br /><br /><pre><br />            ::)<br />                db_metaget $line description<br />                if [ "$RET" ]; then<br />                    name=$RET<br />                else<br />                    name="Unnamed.${unnamed}"<br />                fi<br />                line=''<br />                ;;<br /></pre><br /><br />If a "::" is encountered, the name is fetched from the db database. The metaget command fetches the description of a certain database entry.<br /><br /><pre><br />            .)<br /></pre><br /><br />Now we get to the interesting part. When a "." is encountered, that means an entire partition definition is read in and stored in "$line".<br /><br /><pre><br />                # we correct errors in order not to crash parted_server<br />                set -- $line<br /></pre><br /><br />This is an interesting new thing I found :) The "set" command "parses" what is inside "$line" and returns it parts in "$1", "$2", "$3", etc.<br /><br /><pre><br />                if expr "$1" : '[0-9][0-9]*$' >/dev/null; then<br />                    min=$1<br />                elif expr "$1" : '[0-9][0-9]*%$' >/dev/null; then<br />                    min=$(($ram * ${1%?} / 100))<br />                else # error<br />                    min=2200000000 # there is no so big storage device jet<br />                fi<br /></pre><br /><br />The first argument is the minimum size. If it's not a number and not a percentage of RAM, it's set to 2 200 000 000 MB, which is 2200 PB, large enough if you<br /> ask me.<br /><br /><pre><br />                if expr "$2" : '[0-9][0-9]*%$' >/dev/null; then<br />                    factor=$(($ram * ${2%?} / 100))<br />                elif expr "$2" : '[0-9][0-9]*$' >/dev/null; then<br />                    factor=$2<br />                else # error<br />                    factor=$min # do not enlarge the partition<br />                fi<br /></pre><br /><br />The second argument is the socalled "priority", here stored in "$factor". The same rules as for the minimum apply, except that if the priority is invalid, it<br /> is set to the minimum. This should allow me to just enter "x" as a factor and it should still work.<br /><br /><pre><br />                if [ "$factor" -lt "$min" ]; then<br />                    factor="$min"<br />                fi<br /></pre><br /><br />Sanity check: make sure "$factor" is at least as big as "$min"<br /><br /><pre><br />                if expr "$3" : '[0-9][0-9]*$' >/dev/null; then<br />                    max=$3<br />                elif expr "$3" : '[0-9][0-9]*%$' >/dev/null; then<br />                    max=$(($ram * ${3%?} / 100))<br />                else # error<br />                    max=$min # do not enlarge the partition<br />                fi<br /></pre><br /><br />Argument 3 is the maximum size. Same rules apply. If invalid, it's set to the minimum.<br /><br /><pre><br />                if [ "$max" -lt "$min" ]; then<br />                    max="$min"<br />                fi<br /></pre><br /><br />Another sanity check: max should be at least as large the minimum.<br /><br /><pre><br />                case "$4" in # allow only valid file systems<br />                    ext2|ext3|xfs|reiserfs|jfs|linux-swap|fat16|fat32|hfs)<br />                        fs="$4"<br />                        ;;<br />                    *)<br />                        fs=ext2<br />                        ;;<br />                esac<br /></pre><br /><br />The 4th argument is the type of partition. If it's not in the list, it's set to ext2.<br /><br /><pre><br />                shift; shift; shift; shift<br />                line="$min $factor $max $fs $*"<br />                if [ "$scheme" ]; then<br />                    scheme="${scheme}${NL}${line}"<br />                else<br />                    scheme="$line"<br />                fi<br />                line=''<br />                ;;<br /></pre><br /><br />"shift" removes an argument from the input. 4 times shift removes "$1" "$2" "$3" and "$4", leaving everything behind "$4" in "$*". Now a "cleaned up" "$line"<br /> is created with the sanitized values from above and the rest of the line ($*). It is stored on a new line in "$scheme". This is important. "$scheme" contain<br />s a multiline version of the recipe. (I've peeked ahead) In the future, the recipe will be read in line per line by setting $IFS to "\n".<br /><br /><pre><br />            *)<br />                if [ "$line" ]; then<br />                    line="$line $word"<br />                else<br />                    line="$word"<br />                fi<br />        esac<br /></pre><br /><br />For any other word (not ":" "::" or "."), the word is glued at the end of the current "$line".<br />This completes the circle :)<br /><br /><pre><br />    done<br />}<br /></pre><br /><br />And that was "decode_recipe()".<br />Afaik, this piece of code looks correct. It does what is expected and does some error correction in the process.<br />After this function, the following variables will have been set:<br /><br /><dl><br /><dt>$name</dt><br /><dd>The name of the scheme</dd><br /><dt>$scheme</dt><br /><dd>The parsed version of the recipe. It's a multiline string (separated by \n) with a partition definition on each line</dd><br /></dl><br /><br />Contrary to what I expected, "$ram" is not kept outside of this function (notice the "local ram ..." at the start of the function)<br /><br /><br />The next function I encountered (alot) is the "foreach_partition()" function. It's pretty clear what this function does, but I decided to look at it anyway b<br />ecause it could contain weirdness.<br /><br /><pre><br />foreach_partition () {<br />    local - doing IFS partition former last<br />    doing=$1<br />    IFS="$NL"<br />    former=''<br />    for partition in $scheme; do<br />        restore_ifs<br />        if [ "$former" ]; then<br />            set -- $former<br />            last=no<br />            eval "$doing"<br />        fi<br />        former="$partition" <br />    done<br />    if [ "$former" ]; then<br />        set -- $former<br />        last=yes<br />        eval "$doing"<br />    fi<br />}<br /></pre><br /><br />This looks pretty innocent. Like I said, the partitions in "$scheme" are separated by "\n". In this function, the separate partitions are loaded in "$partiti<br />on" one by one. The variable "$last" is set to "no" for all except the last partition, where it is set to "yes". Then "$doing" is eval'ed.<br /><br />So, the first argument of "foreach_partition()" is the function you want to call on each partition. The partition details (min factor max fs and the rest) ar<br />e passed as "$1", "$2", "$3", ... etc.<br />Furthermore, there is a variable "$last" which indicates whether the current partition is the last one.<br /><br />Interesting to note is that the IFS is not restored for the last partition. I'm not sure whether this is by design or if its a bug. (Notice the "restore_ifs(<br />)" call in the for loop)<br /><br />[after checking]<br />It's not a bug :) The code works as expected. The only time it would not work is if there was nothing in "$scheme", but then "$former" would not be set eithe<br />r.<br /><br />Both "open_dialog()" and "close_dialog()" are interesting as well as it seems they call the parted_server. On closer inspection, "open_dialog()" writes a com<br />mand in a fifo (destination parted_server) and reads the result from another fifo (origin parted_server). It then handles any errors that appear. "close_dial<br />og()" cleans up the fifo's.<br /><br />The fifo's are called /var/lib/partman/infifo and /var/lib/partman/outfifo and are opened on descriptor 6 and 7 respectively.<br /><br />The "read_line()" function reads is a wrapper around "read()" that reads from the outfifo (the output of parted_server)<br /><br />Now here is a promising function: "pull_primary()"<br /><br /><pre><br />pull_primary () {<br />    primary=''<br />    logical=''<br />    foreach_partition '<br />        if<br />            [ -z "$primary" ] \<br />            && echo $* | grep '\''\$primary{'\'' >/dev/null<br />        then<br />            primary="$*"<br />        else<br />            if [ -z "$logical" ]; then<br />                logical="$*"<br />            else<br />                logical="${logical}${NL}$*"<br />            fi<br />        fi'<br />}<br /></pre><br /><br />This function acucmulates data in 2 variables: "$primary" and "$logical". Both are empty at start.<br />Then, it goes over every partition. If it's a primary partition, it is put in "$primary". Otherwise it's appended to "$logical".<br /><br />Now what is interesting, is that only the first primary partition is put in "$primary". The rest is appended to "$logical".<br />Tests confirm it.<br /><br />[At first glance, this seems to be an unfortunate namingscheme for the variables, nothing more.]<br /><br />Some more functions: "partition_before()" and "partition_after()"<br />Both functions return the ID of the partition coming before or after another partition ID.<br />The sort order is defined by what "open_dialog PARTITIONS" returns.<br />The parted_server calls "ped_disk_next_partition()" over and over. I'm guessing it reads the ID's in order then. Now what is outputed is interesting:<br /><pre><br />/* Returns informational string about `part' from `disk'.  Format:*/<br />/* Number<TAB>id<TAB>length<TAB>type<TAB>fs<TAB>path<TAB>name */<br />char *<br />partition_info(PedDisk *disk, PedPartition *part)<br />{<br />        char const *type;<br />        char const *fs;<br />        char *path;<br />        char const *name;<br />        char *result;<br />        assert(disk != NULL && part != NULL);<br />        if (PED_PARTITION_FREESPACE & part->type) {<br />                bool possible_primary = possible_primary_partition(disk, part);<br />                bool possible_logical = possible_logical_partition(disk, part);<br />                if (possible_primary) <br />                        if (possible_logical)<br />                                type = "pri/log";<br />                        else<br />                                type = "primary";<br />                else if (possible_logical)<br />                        type = "logical";<br />                else<br />                        type = "unusable";<br />        } else if (PED_PARTITION_LOGICAL & part->type)<br />                type = "logical";<br />        else<br />                type = "primary";<br /><br />        if (PED_PARTITION_FREESPACE & part->type)<br />                fs = "free";<br />        else if (PED_PARTITION_METADATA & part->type)<br />                fs = "label";<br />        else if (PED_PARTITION_EXTENDED & part->type)<br />                fs = "extended";<br />        else if (NULL == (part->fs_type))<br />                fs = "unknown";<br />        else<br />                fs = part->fs_type->name;<br />        if (0 == strcmp(disk->type->name, "loop")) {<br />                path = strdup(disk->dev->path);<br />/*         } else if (0 == strcmp(disk->type->name, "dvh")) { */<br />/*                 PedPartition *p; */<br />/*                 int count = 1; */<br />/*                 int number_offset; */<br />/*                 for (p = NULL; */<br />/*                      NULL != (p = ped_disk_next_partition(disk, p));) { */<br />/*                         if (PED_PARTITION_METADATA & p->type) */<br />/*                                 continue; */<br />/*                         if (PED_PARTITION_FREESPACE & p->type) */<br />/*                                 continue; */<br />/*                         if (PED_PARTITION_LOGICAL & p->type) */<br />/*                                 continue; */<br />/*                         if (part->num > p->num) */<br />/*                                 count++; */<br />/*                 } */<br />/*                 path = ped_partition_get_path(part); */<br />/*                 number_offset = strlen(path); */<br />/*                 while (number_offset > 0 && isdigit(path[number_offset-1])) */<br />/*                         number_offset--; */<br />/*                 sprintf(path + number_offset, "%i", count); */<br />        } else {<br />                path = ped_partition_get_path(part);<br />        }<br />        if (ped_disk_type_check_feature(part->disk->type,<br />                                        PED_DISK_TYPE_PARTITION_NAME)<br />            && ped_partition_is_active(part))<br />                name = ped_partition_get_name(part);<br />        else<br />                name = "";<br />        asprintf(&result, "%i\t%lli-%lli\t%lli\t%s\t%s\t%s\t%s",<br />                 part->num,<br />                 (part->geom).start * PED_SECTOR_SIZE,<br />                 (part->geom).end * PED_SECTOR_SIZE + PED_SECTOR_SIZE - 1,<br />                 (part->geom).length * PED_SECTOR_SIZE, type, fs, path, name);<br />        free(path);<br />        return result;<br />}<br /></pre><br /><br />Notice the "pri/log" stuff. I suspect it stirring trouble...<br /><br />When I execute the PARTITIONS command myself in vmware by doing:<br /><pre><br />~ # cd /var/lib/partman<br />/var/lib/partman # echo PARTITIONS =dev=scsi=host0=bus0=target0=lun0=disc > infifo<br />/var/lib/partman # cat outfifo<br />OK<br />1        32256-2048094719        2048062464       primary     linux-swap    /dev/scsi/host0/bus0/target0/lun0/part1<br />2        2048094720-2113896959   65802240         primary     ext3          /dev/scsi/host0/bus0/target0/lun0/part2<br />-1       2113896960-5362882559   3248985600       pri/log     free          /dev/scsi/host0/bus0/target0/lun0/part-1<br /></pre><br /><br />(not copy pasted ;)<br /><br />The id "-1" on the 3rd line is interesting. also the "pri/log" and "free".<br /><br />After some looking trough logs, I believe the "-1" stands for empty diskspace.<br />I find the following text in the logs (partman has logs!!!!!! look in /var/log/partman):<br /><pre><br />/bin/perform_recipe: IN: NEW_PARTITION =dev=scsi=host0=bus0=target0=lun0=disc primary ext3 2113896960-5362882559 beginning 3255600001<br />parted_server: Read command: NEW_PARTITION<br />parted_server: command_new_partition()<br />parted_server: Note =dev=scsi=host0=bus0=target0=lun0=disc as changed<br />parted_server: Opening outfifo<br />parted_server: requested partition with type primary<br />parted_server: requested partition with file system ext3<br />parted_server: add_primary_partition(disk(10485760),4128705-10488080)<br />parted_server: OUT: Error<br /><br />parted_server: OUT: Can't have a partition outside the disk!<br /><br />parted_server: OUT:<br /><br />parted_server: OUT: Cancel<br />...<br /></pre><br /><br />I think I may have tripped over the bug here.<br />According to parted_server, there is 3248985600 bytes free for a new partition, but partman wants to create a partition of 3256000001 bytes.<br /><br />I tried with the following sizes and results:<br /><br />3253000000 OK<br />3255000000 NOK<br />3254000000 OK<br />3254500000 OK<br />3254800000 OK<br />3254900000 NOK<br />3254850000 NOK<br />3254830000 NOK<br />3254815000 NOK<br />3254807500 OK<br />3254810000 OK<br />3254812500 NOK<br />3254811250 OK<br />3254811850 OK<br />3254812000 OK<br />3254812250 NOK<br />3254812125 OK<br />3254812200 NOK<br />3254812180 NOK<br />3254812150 OK<br />3254812165 NOK<br />3254812160 NOK<br />3254812155 OK<br />3254812157 OK<br />3254812159 OK<br /><br />I'm not sure where the 3254812159 (max partition size) - 3248985600 (free on disk) = 5826559 bytes come from ?<br /><br />In any case, since the commandline contains the word "beginning", the points of origin are limited to 2 places in the perform_recipe script.<br /><br />And since we defined it as primary, it is most likely that the problem is located here :<br /><br /><pre><br />...<br />while<br />    [ "$free_type" = pri/log ] \<br />    && echo $scheme | grep '\$primary{' >/dev/null<br />do<br />    pull_primary<br />    set -- $primary<br />    open_dialog NEW_PARTITION primary $4 $free_space beginning ${1}000001<br />    read_line num id size type fs path name<br />...<br /></pre><br /><br />The "$free_space" variable is calculated from the last pass through the while loop (when sda2 was created).<br /><br /><pre><br />...<br />    neighbour=$(partition_after $id)<br />    if [ "$neighbour" ]; then<br />        open_dialog PARTITION_INFO $neighbour<br />        read_line x1 new_free_space x2 new_free_type fs x3 x4<br />        close_dialog<br />    fi<br />    if<br />        [ -z "$neighbour" -o "$fs" != free \<br />          -o "$new_free_type" = primary -o "$new_free_type" = unusable ]<br />    then<br /><br />... [we don't get in here]<br /><br />    fi<br />    shift; shift; shift; shift<br />    setup_partition $id $*<br />    primary=''<br />    scheme="$logical"<br />    free_space=$new_free_space<br />    free_type="$new_free_type"<br /></pre><br /><br />"partition_after()" returns "2113896960-5362882559" and it is stored in "$neighbour".<br />Then some PARTITION_INFO is queried for this neighbour. The following variables are set:<br /><br /><dl><br /><dt>$new_free_space</dt><br /><dd>2113896960-5362882559</dd><br /><dt>$new_free_type</dt><br /><dd>pri/log</dd><br /><dt>$fs</dt><br /><dd>free</dd><br /></dl><br /><br />The condition of the if() doesn't match, so that can be skipped. What remains is "setup_partition()" and some variable transfers.<br />Although "setup_partitions()" seems to contain some interesting code (!), it does not alter any non-local variables.<br /><br />We now know where all variables come from in this line:<br /><pre><br />open_dialog NEW_PARTITION primary $4 $free_space beginning ${1}000001<br /></pre><br /><br /><dl><br /><dt>$4</dt><br /><dd>This is the 4th argument of the partition definition of our current partition to create. It's value is "ext3"</dd><br /><dt>$free_space</dt><br /><dd>This is the value stored in $new_free_space of the previous while()-run. The value is obtained from a call to "partition_after()". It's value is 21138969<br />60-5362882559</dd><br /><dt>${1}</dt><br /><dd>This is the first argument of the partition definition. It's the minimum size of the partition, but it went through a number of calculations and election<br />s and actually contains the size to create the partition with.</dd><br /></dl><br /><br />The minimum size is calculated as being 3256 MB:<br />The entire disk is 5368709120 bytes. This is rounded to 5368MB.<br />Then we lose 2048MB and 64MB and a potential 500MB, which gives 2756MB unallocated.<br /><br />We enter the calculation loop with the following data:<br /><br />sda1: 2048 0 2048<br />sda2: 64 0 64<br />sda3: 500 0 1000000000<br />The second number is the "factor" calculated from the "priority"<br /><br />free_space is 5368MB and unallocated is 2756.<br /><br /><pre><br />oldscheme=''<br />while [ "$scheme" != "$oldscheme" ]; do<br />    oldscheme="$scheme"<br />    factsum=$(factor_sum)<br />    unallocated=$(($free_size - $(min_size)))<br />    if [ $unallocated -lt 0 ]; then<br />        unallocated=0<br />    fi<br />    scheme=$(<br />        foreach_partition '<br />            local min fact max newmin<br />            min=$1<br />            fact=$2<br />            max=$3<br />            shift; shift; shift<br />            newmin=$(($min + $unallocated * $fact / $factsum))<br />            if [ $newmin -le $max ]; then<br />                echo $newmin $fact $max $*<br />            else<br />                echo $max 0 $max $*<br />            fi'<br />    )<br />    echo "XXX[$unallocated]"<br />    echo "[$oldscheme][$scheme]";<br />    echo<br />done<br /></pre><br /><br />The key formula here is <code>newmin=$(($min + $unallocated * $fact / $factsum))</code><br /><br />For sda1 and sda2, this doesn't change anything because fact is 0.<br />For sda3, unallocated is 2756, fact is 100 and factsum is also 100 (and I suppose factsum will always be 100 in any case, since it's 100%)<br />So the minimum size for sda3 is calculated to be 500 + 2756*100/100, which is 3256MB<br /><br />OK, let's look at the real data again, because I've been using simulated data.<br />At the start of perform_recipe, the "$free_size" is calculated by means of a PARTITION_INFO command. The result is 5368709120 bytes, rounded to 5368MB.<br /><br />By looking at how partitions are created, I notice an odd thing:<br />The first partition (2048MB) is created starting from offset 32256 and going to 2048094719 having a reported size of 2048062464 bytes (asked for 2048000001 b<br />ytes). The second one is created from 2048094720-2113896959 with reported size of 65802240 bytes (asked for 64000001 bytes).<br />The last partition is obviously not created with a requested size of 3256000001 bytes)<br /><br />The reported sizes added together: 2048062464 + 65802240 + 3254812159 = 5368676863<br />(The 3254812159 is the maximum amount we were allowed to use for the 3rd partition)<br />The disk is 5368709120 bytes, so what remains (full disk - whats in use) = 5368709120 - 5368676863 = 32257 bytes.<br /><br />This happens to be the amount missing from the front of the disk. Probably not coincidence.<br />Maybe the partman-auto author overlooked this.<br /><br />Now that I think of it, 32KB is really not that much... but maybe enough to throw everything out of whack. On the other side, the partition only has to be 1 <br />byte to big for parted_server to fail.<br />Considering that there is a lot of going back and forward between bytes and MB and that megabytes are not calculated cleanly (1000000 bytes instead of 1024*1<br />024), I could be dealing with rounding errors.