---
layout: post
title: 'Something useful with a PIC: serial line communication with the outside'
date: '2008-09-05T13:33:00.009+02:00'
author: Steven Van Acker
tags:
- English
- Ubuntu
- PIC
- Building Stuff
modified_time: '2009-06-23T12:11:15.895+02:00'
blogger_id: tag:blogger.com,1999:blog-5513234137363262204.post-1286145120658407638
blogger_orig_url: http://www.singularity.be/2008/09/something-useful-with-pic-serial-line.html
---

<!-- StevensBlogSpotFilterThing<br />It's been a while since I've touched my k8048 PIC programmer board. This week I put it on my desk again and hooked it up. The plan was to play around with the builtin USART of my 16F627A.<br /><br />Because a PIC is difficult (if not impossible) to debug in hardware, I decided to experiment in software first using a simulator. On Ubuntu, the best simulator is gpsim. It can simulate the USART inside the PIC and allows you to hook up a virtual seriele console to it, to see if things work as expected. There is also a 7-segment led display, a scope and all kinds of other plugins you can use.<br /><br />I write all the programs in assembler and use gpasm (from gputils) to assemble it. The reason for this is that I like to be close to the hardware. After all, it's the hardware part I want to understand and experiment with, so no unnecessary layers of cruft in between!<br /><br />The program I wrote is very basic. It sets up the USART for asynchronous serial communication at 9600 baud (8N1) and then starts sending the alphabet over and over again.<br /><br />Output looks like this:<br />[PRE]<br />BCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKL...<br />[/PRE]<br /><br />(Notice how it didn't start with 'A' ? Thats a bug... keep reading)<br /><br />Here's the code<br />[PRE]<br />#include "p16f627a.inc"<br /><br />#define COUNTER         0x20            ; allocate a var in free space at location 0x20<br />#define STARTCHAR       0x41            ; first character will be 0x41 which is 'A'<br />#define ENDCHAR         0x5A            ; last character will be 'Z'<br /><br />        ; according to the datasheet, both the 1st and 2nd bit of TRISB need to be set to 1, which makes them both inputs<br />        ; this doesn't work. the 2nd bit needs to be set to 0 because it is TX and needs to send bits out.<br />        BSF STATUS, 5                   ;<br />        BSF TRISB, 1                    ; set bit 1 on TRISB<br />        BCF TRISB, 2                    ; clear bit 2 on TRISB<br />        BCF STATUS, 5<br /><br />        ; set baudrate to 9600baud. For a 20MHz Fosc, this is value 32 == 0x20<br />        MOVLW 0x20<br />        BSF STATUS, 5<br />        MOVWF SPBRG<br />        BCF STATUS, 5<br /><br />        BSF STATUS, 5<br />        BCF TXSTA, SYNC                 ; clear SYNC<br />        BCF STATUS, 5<br />        BSF RCSTA, SPEN                 ; enable serial port<br /><br />        BSF STATUS, 5<br />        BSF TXSTA,  TXEN        ; set TXEN<br />        BCF STATUS, 5<br /><br />        ; now the real code begins.<br />        ; a variable COUNTER will contain values from 0 to ENDCHAR-STARTCHAR<br />        ; the register W will hold the actual byte to be sent over the serial line (W = COUNTER + STARTCHAR)<br />        ; if W was ENDCHAR, we reset the COUNTER to 0 and start the whole thing again.<br /><br />reset:  MOVLW 0x0               ; counter = 0<br />        MOVWF COUNTER<br /><br />start:  MOVF   COUNTER, 0       ; w = counter<br />        ADDLW  STARTCHAR        ; w+= startchar<br />        MOVWF  TXREG            ; write w over serial line<br /><br />        ; some hackery to check if W == ENDCHAR: W-ENDCHAR should be 0<br />        SUBLW  ENDCHAR          ; w -= endchar<br />        BTFSC  STATUS, Z        ; if w == 0<br />        GOTO reset              ; reset<br />        INCF COUNTER, 1         ; else, increment counter<br /><br />        ; this tight txloop makes sure that are clear to send the next byte.<br />        ; remember that sending bytes over serial line is slow and it is done in the background<br />        ; if we don't wait untill the first byte is sent, to send the second byte, then the transmission will be garbled<br />        BSF STATUS, 5<br />txloop: BTFSS TXSTA, TRMT<br />        GOTO txloop<br />        BCF STATUS, 5<br /><br />        GOTO start<br />        END<br />[/PRE]<br /><br />And I compiled it like this:<br />[PRE]<br />gpasm -p 16f627a test.asm<br />[/PRE]<br /><br />Which produces a "test.cod" file.<br /><br />I then used the following gpsim "startup command file" (named it env.conf):<br />[PRE]<br /># create a new node 'n'<br />node n<br /><br /># load the gpsim modules library. For some reason I can't just load it from /usr/lib<br /># so to get this working, I had to issue a 'ln -s /usr/lib/libgpsim_modules.so.0 /tmp/libgpsim_modules.so'<br />module lib /tmp/libgpsim_modules.so<br /><br /># create an USART called 'U1'<br />module load usart U1<br /><br /># attach both the TX bit of the PIC 'portb2' (RB2) and the RX pin of the U1 USART<br /># to the node n. This means: connect them together<br />attach n pin(portb2) U1.RXPIN<br /><br /># make the console from the U1 USART do something. In our case, it will display the characters submitted by the PIC<br />U1.console = true<br /><br /># tell the builtin scope in gpsim to monitor portb2 <br /># (in gpsim: Windows -> Scope)<br />scope.ch0="portb2"<br />[/PRE]<br /><br />And launched gpsim with:<br />[PRE]<br />gpsim -c env.conf -s test.cod<br />[/PRE]<br /><br />Screenshot of the scope in gpsim:<br />[FULLIMG:http://data.singularity.be/images/full/2008-09-05-pic16f627a-usart-gpsim/Screenshot-Scope.png]<br />And the usart console:<br />[FULLIMG:http://data.singularity.be/images/full/2008-09-05-pic16f627a-usart-gpsim/Screenshot-USART.png]<br /><br /><br />Careful readers will see that the alphabet sequence does not start with 'A'. I have been looking at the problem very closely and I can't find out why the 'A' is not showing up. All bytes transmitted start with a start-bit and end with a stop-bit, except for the first character transmitted. So you can step through the program and observe how 'A' gets transmitted by using the scope. But nothing arrived in the console. Then 'B' gets sent and everything goes as planned: the startbit, data and stopbits are transmitted and it shows up in the console.<br /><br />I haven't figured out yet why this happens. So dear lazyweb, in case you have any pointers as to why this is (not) happening, please let me know.<br /><br /><br />Some recent links I didn't read through yet completely:<br /><a href="http://zedshaw.com/rants/the_freehackers_union.html">http://zedshaw.com/rants/the_freehackers_union.html</a><br /><br /><a href="http://www.parallax.com/">http://www.parallax.com/</a><br /><br /><br />StevensBlogSpotFilterThing --><br />It's been a while since I've touched my k8048 PIC programmer board. This week I put it on my desk again and hooked it up. The plan was to play around with the builtin USART of my 16F627A.<br /><br />Because a PIC is difficult (if not impossible) to debug in hardware, I decided to experiment in software first using a simulator. On Ubuntu, the best simulator is gpsim. It can simulate the USART inside the PIC and allows you to hook up a virtual seriele console to it, to see if things work as expected. There is also a 7-segment led display, a scope and all kinds of other plugins you can use.<br /><br />I write all the programs in assembler and use gpasm (from gputils) to assemble it. The reason for this is that I like to be close to the hardware. After all, it's the hardware part I want to understand and experiment with, so no unnecessary layers of cruft in between!<br /><br />The program I wrote is very basic. It sets up the USART for asynchronous serial communication at 9600 baud (8N1) and then starts sending the alphabet over and over again.<br /><br />Output looks like this:<br /><pre style="background-color: #EEEEEE; border: black 1px dashed; line-height: 100%; padding: 10px;"><br />BCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKL...<br /></pre><br /><br />(Notice how it didn't start with 'A' ? Thats a bug... keep reading)<br /><br />Here's the code<br /><pre style="background-color: #EEEEEE; border: black 1px dashed; line-height: 100%; padding: 10px;"><br />#include "p16f627a.inc"<br /><br />#define COUNTER         0x20            ; allocate a var in free space at location 0x20<br />#define STARTCHAR       0x41            ; first character will be 0x41 which is 'A'<br />#define ENDCHAR         0x5A            ; last character will be 'Z'<br /><br />        ; according to the datasheet, both the 1st and 2nd bit of TRISB need to be set to 1, which makes them both inputs<br />        ; this doesn't work. the 2nd bit needs to be set to 0 because it is TX and needs to send bits out.<br />        BSF STATUS, 5                   ;<br />        BSF TRISB, 1                    ; set bit 1 on TRISB<br />        BCF TRISB, 2                    ; clear bit 2 on TRISB<br />        BCF STATUS, 5<br /><br />        ; set baudrate to 9600baud. For a 20MHz Fosc, this is value 32 == 0x20<br />        MOVLW 0x20<br />        BSF STATUS, 5<br />        MOVWF SPBRG<br />        BCF STATUS, 5<br /><br />        BSF STATUS, 5<br />        BCF TXSTA, SYNC                 ; clear SYNC<br />        BCF STATUS, 5<br />        BSF RCSTA, SPEN                 ; enable serial port<br /><br />        BSF STATUS, 5<br />        BSF TXSTA,  TXEN        ; set TXEN<br />        BCF STATUS, 5<br /><br />        ; now the real code begins.<br />        ; a variable COUNTER will contain values from 0 to ENDCHAR-STARTCHAR<br />        ; the register W will hold the actual byte to be sent over the serial line (W = COUNTER + STARTCHAR)<br />        ; if W was ENDCHAR, we reset the COUNTER to 0 and start the whole thing again.<br /><br />reset:  MOVLW 0x0               ; counter = 0<br />        MOVWF COUNTER<br /><br />start:  MOVF   COUNTER, 0       ; w = counter<br />        ADDLW  STARTCHAR        ; w+= startchar<br />        MOVWF  TXREG            ; write w over serial line<br /><br />        ; some hackery to check if W == ENDCHAR: W-ENDCHAR should be 0<br />        SUBLW  ENDCHAR          ; w -= endchar<br />        BTFSC  STATUS, Z        ; if w == 0<br />        GOTO reset              ; reset<br />        INCF COUNTER, 1         ; else, increment counter<br /><br />        ; this tight txloop makes sure that are clear to send the next byte.<br />        ; remember that sending bytes over serial line is slow and it is done in the background<br />        ; if we don't wait untill the first byte is sent, to send the second byte, then the transmission will be garbled<br />        BSF STATUS, 5<br />txloop: BTFSS TXSTA, TRMT<br />        GOTO txloop<br />        BCF STATUS, 5<br /><br />        GOTO start<br />        END<br /></pre><br /><br />And I compiled it like this:<br /><pre style="background-color: #EEEEEE; border: black 1px dashed; line-height: 100%; padding: 10px;"><br />gpasm -p 16f627a test.asm<br /></pre><br /><br />Which produces a "test.cod" file.<br /><br />I then used the following gpsim "startup command file" (named it env.conf):<br /><pre style="background-color: #EEEEEE; border: black 1px dashed; line-height: 100%; padding: 10px;"><br /># create a new node 'n'<br />node n<br /><br /># load the gpsim modules library. For some reason I can't just load it from /usr/lib<br /># so to get this working, I had to issue a 'ln -s /usr/lib/libgpsim_modules.so.0 /tmp/libgpsim_modules.so'<br />module lib /tmp/libgpsim_modules.so<br /><br /># create an USART called 'U1'<br />module load usart U1<br /><br /># attach both the TX bit of the PIC 'portb2' (RB2) and the RX pin of the U1 USART<br /># to the node n. This means: connect them together<br />attach n pin(portb2) U1.RXPIN<br /><br /># make the console from the U1 USART do something. In our case, it will display the characters submitted by the PIC<br />U1.console = true<br /><br /># tell the builtin scope in gpsim to monitor portb2 <br /># (in gpsim: Windows -> Scope)<br />scope.ch0="portb2"<br /></pre><br /><br />And launched gpsim with:<br /><pre style="background-color: #EEEEEE; border: black 1px dashed; line-height: 100%; padding: 10px;"><br />gpsim -c env.conf -s test.cod<br /></pre><br /><br />Screenshot of the scope in gpsim:<br /><a href="http://data.singularity.be/images/full/2008-09-05-pic16f627a-usart-gpsim/Screenshot-Scope.png"><img src="http://data.singularity.be/images/full/2008-09-05-pic16f627a-usart-gpsim/Screenshot-Scope.png"></a><br />And the usart console:<br /><a href="http://data.singularity.be/images/full/2008-09-05-pic16f627a-usart-gpsim/Screenshot-USART.png"><img src="http://data.singularity.be/images/full/2008-09-05-pic16f627a-usart-gpsim/Screenshot-USART.png"></a><br /><br /><br />Careful readers will see that the alphabet sequence does not start with 'A'. I have been looking at the problem very closely and I can't find out why the 'A' is not showing up. All bytes transmitted start with a start-bit and end with a stop-bit, except for the first character transmitted. So you can step through the program and observe how 'A' gets transmitted by using the scope. But nothing arrived in the console. Then 'B' gets sent and everything goes as planned: the startbit, data and stopbits are transmitted and it shows up in the console.<br /><br />I haven't figured out yet why this happens. So dear lazyweb, in case you have any pointers as to why this is (not) happening, please let me know.<br /><br /><br />Some recent links I didn't read through yet completely:<br /><a href="http://zedshaw.com/rants/the_freehackers_union.html">http://zedshaw.com/rants/the_freehackers_union.html</a><br /><br /><a href="http://www.parallax.com/">http://www.parallax.com/</a>