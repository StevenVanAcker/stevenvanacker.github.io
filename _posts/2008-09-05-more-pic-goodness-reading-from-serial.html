---
layout: post
title: 'More PIC goodness: reading from serial line'
date: '2008-09-05T18:25:00.003+02:00'
author: Steven Van Acker
tags:
- English
- Ubuntu
- PIC
- Building Stuff
modified_time: '2008-09-05T18:31:01.054+02:00'
blogger_id: tag:blogger.com,1999:blog-5513234137363262204.post-6118810244461897743
blogger_orig_url: http://www.singularity.be/2008/09/more-pic-goodness-reading-from-serial.html
---

<!-- StevensBlogSpotFilterThing<br />Now that I figured out serial communications, I can start to do more interesting things. One of those things is having the PIC read from the serial line and doing something with the data. I decided I would read in characters '0' through '9', and render them on a 7-segment led display.<br /><br />This is the code:<br />[PRE]<br />#include "p16f627a.inc"<br /><br />#define ARRAY   0x20                    ; allocate a var in free space at location 0x20<br />        __CONFIG _INTOSC_OSC_NOCLKOUT<br /><br />; a macro to easily load data into memory<br />putdata: MACRO idx, val<br />         MOVLW val<br />         MOVWF (ARRAY + idx)<br />         ENDM<br /><br />        ; 7 segment led display: <br />        ;       0<br />        ;     -----  <br />        ;   |       |<br />        ; 5 |       | 1<br />        ;   |   6   |<br />        ;     -----  <br />        ;   |       |<br />        ; 4 |       | 2<br />        ;   |       |<br />        ;     -----  <br />        ;       3<br /><br />        ; store all 10 digits, starting at address ARRAY<br />        putdata 0, 0x3F ;0011 1111<br />        putdata 1, 0x06 ;0000 0110<br />        putdata 2, 0x5B ;0101 1011<br />        putdata 3, 0x4F ;0100 1111<br />        putdata 4, 0x66 ;0110 0110<br />        putdata 5, 0x6D ;0110 1101<br />        putdata 6, 0x7D ;0111 1101<br />        putdata 7, 0x07 ;0000 0111<br />        putdata 8, 0x7F ;0111 1111<br />        putdata 9, 0x6F ;0110 1111<br /><br />        BSF STATUS, 5                   ;<br />        ; according to the datasheet, both the 1st and 2nd bit of TRISB need to be set to 1, which makes them both inputs<br />        BSF TRISB, 1                    ; set bit 1 on TRISB<br />        BSF TRISB, 2                    ; set bit 2 on TRISB<br />        CLRF TRISA                      ; PORTA is all output<br />        BCF STATUS, 5<br /><br />        ; set baudrate to 9600baud. For a 20MHz Fosc, this is value 32 == 0x20<br />        MOVLW 0x20<br />        BSF STATUS, 5<br />        MOVWF SPBRG<br />        BCF STATUS, 5<br /><br />        BSF STATUS, 5<br />        BCF TXSTA, SYNC                 ; clear SYNC<br />        BCF STATUS, 5<br />        BSF RCSTA, SPEN                 ; enable serial port<br />        BSF RCSTA, CREN                 ; set CREN<br /><br />wait:   BTFSS PIR1, RCIF                ; wait untill there is some input<br />        GOTO wait<br /><br />        MOVF RCREG, 0           ; read the data byte<br />        ADDLW 0xD0              ; index = data - 0x30 ('0') (ADDLW 0xD0 = DECLW 0x30)<br />        ADDLW ARRAY             ; pointer = ARRAY + index<br />        MOVWF FSR               ; set the pointer <br />        MOVF  INDF,0            ; w = *pointer<br />        MOVWF PORTA             ; porta = w -> lights up the 7seg leds<br /><br />        GOTO wait<br /><br />        END<br />[/PRE]<br /><br />compile with<br />[PRE]<br />gpasm -p 16f627a test.asm<br />[/PRE]<br /><br />And this is the gpsim startup commands file:<br />[PRE]<br /># load the gpsim modules library. For some reason I can't just load it from /usr/lib<br /># so to get this working, I had to issue a 'ln -s /usr/lib/libgpsim_modules.so.0 /tmp/libgpsim_modules.so'<br />module lib /tmp/libgpsim_modules.so<br /><br /># creating an usart and connecting its TX pin to the PICs RX pin, allowing keyboard input<br />module load usart U1<br />node nc<br />attach nc pin(portb1) U1.TXPIN<br />U1.console = true<br /><br /># creating a 7 segment led display and hooking it up to PORTA<br />module load led_7segments L7<br />node nl0 nl1 nl2 nl3 nl4 nl5 nl6<br />attach nl0 pin(porta0) L7.seg0<br />attach nl1 pin(porta1) L7.seg1<br />attach nl2 pin(porta2) L7.seg2<br />attach nl3 pin(porta3) L7.seg3<br />attach nl4 pin(porta4) L7.seg4<br />attach nl5 pin(porta5) L7.seg5<br />attach nl6 pin(porta6) L7.seg6<br /><br /># tell the builtin scope in gpsim to monitor portb2<br /># (in gpsim: Windows -> Scope)<br />#scope.ch0="portb1"<br />[/PRE]<br /><br />Start gpsim with this command:<br />[PRE]<br />gpsim -c env.conf -s test.cod<br />[/PRE]<br /><br />[FULLIMG:http://data.singularity.be/images/full/2008-09-05-pic16f627a-usart-gpsim/Screenshot-Breadboard.png]<br />StevensBlogSpotFilterThing --><br />Now that I figured out serial communications, I can start to do more interesting things. One of those things is having the PIC read from the serial line and doing something with the data. I decided I would read in characters '0' through '9', and render them on a 7-segment led display.<br /><br />This is the code:<br /><pre style="background-color: #EEEEEE; border: black 1px dashed; line-height: 100%; padding: 10px;"><br />#include "p16f627a.inc"<br /><br />#define ARRAY   0x20                    ; allocate a var in free space at location 0x20<br />        __CONFIG _INTOSC_OSC_NOCLKOUT<br /><br />; a macro to easily load data into memory<br />putdata: MACRO idx, val<br />         MOVLW val<br />         MOVWF (ARRAY + idx)<br />         ENDM<br /><br />        ; 7 segment led display: <br />        ;       0<br />        ;     -----  <br />        ;   |       |<br />        ; 5 |       | 1<br />        ;   |   6   |<br />        ;     -----  <br />        ;   |       |<br />        ; 4 |       | 2<br />        ;   |       |<br />        ;     -----  <br />        ;       3<br /><br />        ; store all 10 digits, starting at address ARRAY<br />        putdata 0, 0x3F ;0011 1111<br />        putdata 1, 0x06 ;0000 0110<br />        putdata 2, 0x5B ;0101 1011<br />        putdata 3, 0x4F ;0100 1111<br />        putdata 4, 0x66 ;0110 0110<br />        putdata 5, 0x6D ;0110 1101<br />        putdata 6, 0x7D ;0111 1101<br />        putdata 7, 0x07 ;0000 0111<br />        putdata 8, 0x7F ;0111 1111<br />        putdata 9, 0x6F ;0110 1111<br /><br />        BSF STATUS, 5                   ;<br />        ; according to the datasheet, both the 1st and 2nd bit of TRISB need to be set to 1, which makes them both inputs<br />        BSF TRISB, 1                    ; set bit 1 on TRISB<br />        BSF TRISB, 2                    ; set bit 2 on TRISB<br />        CLRF TRISA                      ; PORTA is all output<br />        BCF STATUS, 5<br /><br />        ; set baudrate to 9600baud. For a 20MHz Fosc, this is value 32 == 0x20<br />        MOVLW 0x20<br />        BSF STATUS, 5<br />        MOVWF SPBRG<br />        BCF STATUS, 5<br /><br />        BSF STATUS, 5<br />        BCF TXSTA, SYNC                 ; clear SYNC<br />        BCF STATUS, 5<br />        BSF RCSTA, SPEN                 ; enable serial port<br />        BSF RCSTA, CREN                 ; set CREN<br /><br />wait:   BTFSS PIR1, RCIF                ; wait untill there is some input<br />        GOTO wait<br /><br />        MOVF RCREG, 0           ; read the data byte<br />        ADDLW 0xD0              ; index = data - 0x30 ('0') (ADDLW 0xD0 = DECLW 0x30)<br />        ADDLW ARRAY             ; pointer = ARRAY + index<br />        MOVWF FSR               ; set the pointer <br />        MOVF  INDF,0            ; w = *pointer<br />        MOVWF PORTA             ; porta = w -> lights up the 7seg leds<br /><br />        GOTO wait<br /><br />        END<br /></pre><br /><br />compile with<br /><pre style="background-color: #EEEEEE; border: black 1px dashed; line-height: 100%; padding: 10px;"><br />gpasm -p 16f627a test.asm<br /></pre><br /><br />And this is the gpsim startup commands file:<br /><pre style="background-color: #EEEEEE; border: black 1px dashed; line-height: 100%; padding: 10px;"><br /># load the gpsim modules library. For some reason I can't just load it from /usr/lib<br /># so to get this working, I had to issue a 'ln -s /usr/lib/libgpsim_modules.so.0 /tmp/libgpsim_modules.so'<br />module lib /tmp/libgpsim_modules.so<br /><br /># creating an usart and connecting its TX pin to the PICs RX pin, allowing keyboard input<br />module load usart U1<br />node nc<br />attach nc pin(portb1) U1.TXPIN<br />U1.console = true<br /><br /># creating a 7 segment led display and hooking it up to PORTA<br />module load led_7segments L7<br />node nl0 nl1 nl2 nl3 nl4 nl5 nl6<br />attach nl0 pin(porta0) L7.seg0<br />attach nl1 pin(porta1) L7.seg1<br />attach nl2 pin(porta2) L7.seg2<br />attach nl3 pin(porta3) L7.seg3<br />attach nl4 pin(porta4) L7.seg4<br />attach nl5 pin(porta5) L7.seg5<br />attach nl6 pin(porta6) L7.seg6<br /><br /># tell the builtin scope in gpsim to monitor portb2<br /># (in gpsim: Windows -> Scope)<br />#scope.ch0="portb1"<br /></pre><br /><br />Start gpsim with this command:<br /><pre style="background-color: #EEEEEE; border: black 1px dashed; line-height: 100%; padding: 10px;"><br />gpsim -c env.conf -s test.cod<br /></pre><br /><br /><a href="http://data.singularity.be/images/full/2008-09-05-pic16f627a-usart-gpsim/Screenshot-Breadboard.png"><img src="http://data.singularity.be/images/full/2008-09-05-pic16f627a-usart-gpsim/Screenshot-Breadboard.png"></a>